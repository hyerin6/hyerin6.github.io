<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Garbage Collection(1)</title>

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css" type="text/css">

  <!-- Font -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css' rel='stylesheet' type='text/css'>
  <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Hyerin Blog" href="/feed.xml" />
  <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Garbage Collection(1) | Hyerin Blog</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Garbage Collection(1)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Java garbage collection 개념" />
<meta property="og:description" content="Java garbage collection 개념" />
<link rel="canonical" href="http://localhost:4000/2020-03-23/GC/" />
<meta property="og:url" content="http://localhost:4000/2020-03-23/GC/" />
<meta property="og:site_name" content="Hyerin Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-03-23T00:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Garbage Collection(1)" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2020-03-23/GC/","headline":"Garbage Collection(1)","dateModified":"2020-03-23T00:00:00+09:00","datePublished":"2020-03-23T00:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2020-03-23/GC/"},"@type":"BlogPosting","description":"Java garbage collection 개념","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8RJ9ZZ1LSQ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8RJ9ZZ1LSQ', { 'anonymize_ip': false});
</script>


</head>

<body>
  <div class="content-container">
    <header>
  <div class="header-small">
    <a href="http://localhost:4000">Hyerin Blog</a>
  </div>
</header>
<div class="post">
  <div class="post-title">Garbage Collection(1)</div>
  <br />
  <span class="post-date">
    <time>23 Mar 2020</time>
  </span>

  <div class="post-tag">
    <ul>
      
      <li>
        <a href="http://localhost:4000/tags#java">
          <span>java</span>
        </a>
      </li>
      
      
    </ul>
  </div>

  <h3 id="1-개념">1. 개념</h3>
<h4 id="1-garbage-collection">1) garbage collection</h4>
<p>Java 언어에서 new 연산자를 사용하여 생성된 객체가, 자동으로 제거되는 것을 garbage collection 이라 한다.<br />
어떤 객체를 참조하는 변수가 하나라도 있다면, 그 객체는 사용되고 있는 것이고,<br />
반대로 어떤 객체를 참조하는 변수가 하나도 없다면, 그 객체는 사용될 수 없으니 garbage collection 된다.</p>

<p>garbage collection은 JVM(Java virtual machine)에 의해서 자동으로 실행되는데,    <br />
(방문해보면서 mark 해놨는데 가리키고 있는게 아무것도 없는데 존재하면 그게 garbage 이다.)  <br />
이걸 확인하려면 메모리를 다 둘러봐야해서 시간이 꽤 걸리는 작업이기 때문에, 가끔 실행된다.</p>

<ul>
  <li>
    <p>stop-the-world   <br />
garbage collection이 실행될 때, 그 JVM(Java virtual machine)에서 애플리케이션은 모두 정지되고,    <br />
오로지 garbage collection 작업만 실행된다.      <br />
즉 application thread는 모두 정지되고, garbage collection thread만 실행된다.       <br />
성능이 매우 중요한 애플리케이션의 경우에, garbage collection 동안 애플리케이션이 정지되는 것이 문제가 될 수 있다.</p>
  </li>
  <li>
    <p>System.gc()    <br />
garbage collection 작업을 즉시 실행하도록 명령하는 메소드이다.
이 메소드를 호출하지 말자. virtual machine 스스로 garbage collection 할 때를 결정하도록 놔두자.</p>
  </li>
</ul>

<p>System은 클래스이다.
gc()는 System 클래스의 static 메소드이다.</p>

<p>Q. 그렇다면 garbage collection이 자동으로 잘 처리 되도록 하려면 어떻게 해야할까?  <br />
A. 더 이상 사용하지 않는 객체를 참조하고 있는 변수에 null을 대입하자. <br />
변수에 의해 참조되지 않는 객체는 자동으로 garbage collection이 되기 때문이다.</p>

<p><br /></p>

<h4 id="2-weak-generational-hypothesis">2) weak generational hypothesis</h4>
<p>많은 경우에 Java 객체는 다음과 같은 특징을 갖는다.</p>
<ul>
  <li>대부분의 객체는 짧은 시간 안에 garbage가 된다. -&gt; 지역변수</li>
  <li>오래된 객체의 멤버변수가 젊은 객체를 참조하는 경우는 아주 드물다. -&gt; 영역이 다르다.</li>
</ul>

<p><strong>대부분의 객체는 짧은 시간 안에 garbage가 된다.</strong>  <br />
메소드 내에서 잠깐 사용되고 끝나는 객체가 많다.<br />
이런 객체는 지역 변수에 대입하여 사용한다.<br />
메소드가 리턴될 때, 지역 변수가 없어지면, 그 지역 변수에 의해서만 참조되던 객체는 garbage가 되고, garbage collection 대상이 된다.</p>

<p><strong>오래된 객체</strong>  <br />
지역 변수가 아니라, 멤버 변수에 의해 참조되는 객체는 일찍 제거되지 않고 꽤 오래 살아남는다. <br />
static 멤버 변수에 의해 참조되는 객체는 더욱 오래 살아남는다. <br />
즉 지역 변수가 참조하는 객체들은 금방 garbage collection 되지만, <br />
멤버 변수가 참조하는 객체들은 꽤 오래 살아남는다.</p>

<p><strong>오래된 객체의 멤버변수가 젊은 객체를 참조하는 경우는 아주 드물다.</strong>            <br />
오래된 객체의 멤버 변수가 참조하는 객체도 오래된 객체일 확률이 높고, 일찍 제거될 객체일 확률은 낮다.<br />
일찍 제거될 객체는 대부분 지역 변수에 대입되어 사용되기 때문이다.</p>

<p>위 특징들을 활용하여 Java virtual machine의 garbage collection 기능이 구현되었다.  <br />
garbage collection의 성능이 좋아진 원인은 이러한 특징을 잘 잡았기 때문이다.</p>

<p><br /></p>

<h4 id="3-java-컴파일">3) Java 컴파일</h4>
<ul>
  <li>HotSpot     <br />
Oracle이 만든 Java virtual machine의 이름이 Java HotSpot Performance Engine 이다.<br />
줄여서, HotSpot virtual machine 이라고 부르거나, 그냥 HotSpot 이라고 부른다.<br />
즉 HotSpot은 Oracle이 만든 Java virtual machine의 제품명이다.</li>
</ul>

<p><br /></p>

<ul>
  <li>C/C++ 컴파일<br />
C/C++ 컴파일러는 C/C++ 소스 코드를 기계어 코드로 변환한다.         <br />
C/C++ 소스 파일을 컴파일하여 생성된 *.exe 실행 파일에는 기계어 코드가 들어있다.         <br />
*.exe 파일은 직접 CPU에서 실행된다.         <br />
실행 파일의 구조는 운영체제에 따라 다르다.</li>
</ul>

<p><br /></p>

<ul>
  <li>표준 Java 컴파일<br />
표준 Java 컴파일러는 Java 소스 코드를 bytecode로 컴파일한다.         <br />
*.java 소스 파일을 컴파일하여 생성된 *.class 파일에는 bytecode가 들어있다.         <br />
Java virtual machine이 *.class 파일을 읽어서 bytecode를 실행한다. <br />             <br />
표준 Java 컴파일러 실행 파일은 javac.exe 이다.           <br />
표준 Java 가상 기계 실행 파일은 java.exe 이다.</li>
</ul>

<p><br /></p>

<ul>
  <li>bytecode로 컴파일하는 이유       <br />
기계어 코드로 컴파일 하지 않고 bytecode로 컴파일하는 방식의 장단점은 다음과 같다.   <br />
<br />
    <ul>
      <li>단점: 약간 느리다.       <br />
   CPU가 기계어 코드를 직접 읽어서 실행하는 방식이 가장 빠르다. <br />             <br />
   <br /></li>
      <li>장점: CPU에 독립적이고, 운영체제에 독립적이다.    <br />
  실행파일에 들어있는 기계어 코드는 CPU마다 다르다.    <br />
  실행파일 구조는 운영체제마다 다르다.    <br />
  그래서 Windows 실행파일을 맥에서 실행할 수 없다. <br />    <br />
  Java 소스파일을 컴파일하여 생성된 *.class 파일의 구조는 운영체제에 무관하다.       <br />
  그리고 bytecode도 CPU에 무관하다.       <br />
  따라서 Java로 개발한 앱은, 특정 운영체제나 CPU에 무관하게 배포될 수 있고,       <br />
  Java virtual machine만 있으면 실행될 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>JIT 컴파일 (Just In Time compilation)       <br />
Java는 JIT 컴파일 방식을 사용한다.       <br />
JIT 컴파일이란, bytecode를 실행하기 직전에 기계어 코드로 컴파일 하는 방식을 말한다.
Java virtual machine은 실행하기 직전에, bytecode를 기계어 코드로 변환(컴파일)해서 실행한다.           <br />
bytecode를 해석해서 실행하는 것보다(인터프리터 방식), 기계어 코드로 변환해서 실행하는 쪽이 훨씬 더 빠르기 때문이다.           <br />
Java virtual machine 내부에는 JIT 컴파일러가 내장되어 있다.           <br />
이 JIT 컴파일러는 bytecode를 기계어 코드로 변환한다.</li>
</ul>

<p><br /></p>

<ul>
  <li>JVM JIT 컴파일 방식의 장단점<br />
JVM(Java virtual machine)
    <ul>
      <li>단점: 변환된 기계어 코드를 따로 저장하지는 않기 때문에, 실행할 때마다 매번 다시 JIT 컴파일 해야 한다.</li>
      <li>장점: dynamic optimization 가능</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>dynamic optimization    <br />
컴파일러가 소스코드를 컴파일할 때, 소스코드와 동일한 순서로 기계어 코드를 생성하지 않고,    <br />
좀 더 빠르고 효율적으로 실행될 수 있도록, 실행 순서를 재배치하고 조정하여, 기계어 코드를 생성하는 것을,     <br />
컴파일러 최적화(compiler optimization)라고 한다. <br />     <br />
소스코드를 컴파일할 때가 아니고, 실행하는 시점에, 실행 순서를 재배치하고 조정하여 기계어 코드를 생성하는 것을, 동적 최적화(dynamic optimization)라고 한다.  <br />
JVM의 JIT 컴파일러는 dynamic optimization을 수행한다.</li>
</ul>

<p><br /></p>

<h4 id="4-process와-virtual-memory">4) process와 virtual memory</h4>
<p>애플리케이션이 운영체제 메모리로 로드(load)되어 실행될 때, 이것을 프로세스(process)라고 부른다. <br />
즉 운영체제 메모리로 로드되어 실행되는 애플리케이션을 프로세스라고 부른다.</p>

<p>운영체제는 프로세스에게 자원을 제공한다. 제공되는 자원은, 메모리, 파일, 소켓(socket), 세마포어(semaphore), 파이프(pipe) 등이다.  <br />
운영체제에 의해서, 각각의 프로세스는 서로 격리된다.  <br />
어떤 프로세스의 메모리나 자원을, 다른 프로세스가 건드릴 수 없다. <br />
<br /></p>

<ul>
  <li>virtual memory        <br />
프로세스가 사용하는 메모리 주소는, 실제 메모리의 물리적 주소가 아니고, 가상의 주소이다. (virtual memory 주소) <br />
이 가상의 주소는, 운영체제와 CPU에 의해서, DRAM 부품의 물리적 주소로 변환되어 실행된다. <br />
어느 프로세스가 다른 프로세스나 운영체제 커널(kernel)의 물리적 메모리 주소를 사용하는 것은 불가능하다.<br />
운영체제와 CPU가 그런 주소 변환을 허용하지 않기 때문이다.  <br />
즉, 어느 프로세스는 자신에게 주어진 virtual memory 주소만 사용할 수 있고, 자신에게 주어진 메모리에만 접근할 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li>Intel CPU meltdown 결함       <br />
2017년에 문제가 되었던 인텔 CPU의 meltdown결함은, virtual memory 주소를 물리 주소로 변환하는 인텔 CPU의 기능에 헛점이 있다는 것이다. <br />
이 결함을 이용하면, 운영체제 커널의 메모리 주소나, 다른 프로세스의 메모리 주소를 알아내고, 그 메모리에 접근하는 것이 가능하게 된다.<br />
그래서, 결함이 있는 Intel CPU의 주소 변환 기능을 사용하지 않고, CPU가 담당했던 주소 변환까지 운영체제가 수행하도록 수정하는 것이, meltdown 결함 패치(patch)의 내용이다.   <br />
CPU가 하던 기능을 운영체제 SW가 해야 하므로, 이 패치를 적용하면, 컴퓨터가 조금 느려진다.</li>
</ul>

<p><br /></p>

<h4 id="5-stack-heap-data-text-segment">5) stack, heap, data, text segment</h4>
<p>프로세스에게 주어진 메모리 공간은 세그먼트들로 나눠 사용된다.</p>

<ul>
  <li>text segment (code segment)           <br />
기계어 코드가 위치한 영역을 text segment라 한다.          <br />
소스코드에 포함된 문자열 상수가 숫자 상수들도 여기에 위치하는 경우도 있는데,           <br />
특정 컴파일러나 운영체제에서는 다를 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li>heap segment          <br />
동적으로 할당되고 반납되는 메모리가 위치한 영역이다.          <br />
C언어의 malloc/free 함수를 사용하여 할당된 메모리는 heap에 위치한다.          <br />
Java 언어의 new 연산자를 사용하여 생성한 객체/배열은 heap에 위치한다.          <br />
Java에서 참조형 값들은 전부 heap에 위치한다.          <br />
heap 영역에서 불필요한 객체를 찾아 제거하는 작업이 garbage collection 이다.          <br />
Java의 garbage collection은 JVM에 의해서 자동으로 실행된다.</li>
</ul>

<p><br /></p>

<ul>
  <li>data segment          <br />
프로세스가 시작할 때부터 종료될 때까지 존재하는 변수들이 위치한 영역이다.          <br />
전역변수, static 지역 변수, static 멤버 변수가 여기에 위치한다. (C/C++ 언어) <br />            <br />
Java 언어에는 전역변수, static 지역 변수가 없다.          <br />
Java 언어는 data segment라고 부르지 않는다.          <br />
Java 언어의 static 멤버 변수는 metaplace 영역에 위치한다.</li>
</ul>

<p><br /></p>

<ul>
  <li>stack segment                 <br />
stack segment는 함수나 메소드 호출 과정에서 사용되는 메모리 영역이다.          <br />
함수가 호출될 때 생성되는 지역 변수, 파라미터 변수가 stack segment에 생성된다.          <br />
함수의 리턴 값이나, 함수가 리턴할 때 되돌아갈 기계에 코드의 주소도 여기에 저장된다.</li>
</ul>

<p><br /></p>

<ul>
  <li>stack overflow 공격  <br />
함수가 리턴될 때 되돌아갈 기계에 코드의 주소가 stack segment에 저장되고,<br />
지역 변수도 stack segment에 저장된다는 점을 노린 해킹 공격이다. <br /><br />
공격할 SW의 기계어 코드를 분석하여, 네트워크로 전송된 데이터가 어떤 함수의 지역 변수 배열에 저장되는 경우를 찾는다. <br />
그 지역 변수 배열의 크기보다 더 큰 데이터를 전송해서, <br />
데이터가 저장될 때, 배열의 뒤까지 넘치도록(overflow) 한다. <br />
이렇게 넘쳐서 저장된 데이터가 함수가 리턴 주소가 저장된 곳까지 덮어쓰도록 한다. <br />
함수가 리턴할 때, overflow 되어 변경된 주소로 리턴하게 된다. <br />
즉 해커가 원하는 곳으로 리턴하게 되어 해커가 심어 놓은 기계어 코드가 실행하게 된다.</li>
</ul>

<p><br /></p>

<ul>
  <li>stack overflow 공격 막기 <br />
배열에 데이터를 저장하거나 복사할 때, 배열의 범위를 벗어나서 넘치게(overflow) 저장하지 말아야 한다.  <br />
Java 언어의 경우에는, VM이 이것을 검사하기 때문에, overflow가 가능하지 않다.  <br />
따라서 Java는 stack overflow 공격에 안전하다. <br />
배열의 크기를 벗어난 곳에 접근하려 하는 경우에, Java에서는 IndexOutOfBoundsException이 발생한다. <br />  <br />
C/C++ 언어에서는 overflow가 가능하므로, 코딩할 때 주의해야 한다.  <br />
그리고 overflow를 검사하지 않는 표준 함수의 사용을 자제하고 (예: strcpy, strcat, memcpy, sprinf) <br />
overflow를 검사하는 표준 함수를 사용해야 한다. (예: strncpy, strncat, memcpy, snprintf)</li>
</ul>

<p><br /></p>

<h4 id="6-process와-thread">6) process와 thread</h4>
<p>process 내부에 thread가 생성된다.  <br />
process가 시작될 때, main thread가 자동으로 생성되고,  <br />
다른 스레드는 스레드 생성 명령을 실행하여 생성해야 한다. <br />  <br />
스레드는 stack segment를 따로 소유한다.  <br />
스레드를 한 개 생성할 때마다, stack segment도 한 개 생성해서, thread에게 할당해야 한다.  <br />
heap segment, data, text segment는 thread들 사이에 공유된다.</p>

<ul>
  <li>ThreadLocal     <br />
Java 표준 라이브러리에 ThreadLocal 클래스가 있다.    <br />
thread들 사이에 공유되지 않는 객체를 생성하기 위해 ThreadLocal 클래스를 사용한다.</li>
</ul>

<p><br /></p>

<h5 id="7-hotspot-java-virtual-machine-구조">7) HotSpot java virtual machine 구조</h5>
<p>HotSpot JVM의 주요 구성요소는 다음과 같다.</p>
<ul>
  <li>Class Loader      : 클래스 파일(*.class)을 메모리에 불러오는 역할을 담당</li>
  <li>Runtime Data Area : 데이터를 보관하는 메모리 영역</li>
  <li>Execution Engine  : 실행 엔진</li>
</ul>

<p><br /></p>

<p>runtime data areas 내부에서    <br />
<strong>method area</strong>   <br />
이영역에서 위치한 항목들은 다음과 같다.</p>
<ul>
  <li>method의 bytecode</li>
  <li>static 멤버 변수</li>
  <li>constant 값</li>
</ul>

<p>method area 이름은 자주 사용되는 이름이 아니다. <br />
이 영역의 대표적인 이름은, permanenet generation 영역이다. (Java7까지)<br />
Java8 부터 이 영역의 이름이 metaplace로 바뀌었다. (세부 구조도 변경되었다.)</p>

<p><br /></p>

<ul>
  <li>heap  <br />
Java 객체와 배열이 생성되는 영역이다. (heap segment)     <br />
garbage collection은, 더 이상 사용되지 않는 객체를 메모리에서 삭제하는 작업이다.     <br />
Java 객체들은 heap 영역에 위치한다. 즉 garbage collection 작업은 heap 영역을 청소하는 작업이다.</li>
</ul>

<p><br /></p>

<ul>
  <li>Java stack        <br />
지역 변수와 파라미터 변수가 생성되는 영역이다.      <br />
Java 메소드가 호출될 때, 그 메소드의 지역 변수와 파라미터 변수가 생성될 공간이 할당되어야 한다.      <br />
이 공간은, 메소드가 리턴될 때 반납된다. stack segment에 이 공간이 할당된다.      <br />
Java 메소드가 호출될 때 사용되는 stack segment를 Java stack 이라고 한다. <br />         <br />
각 thread 마다 stack segment를 따로 소유한다.       <br />
즉 새 thread가 생성되면, 그 thread가 사용할 stack segment를 할당해야 한다.</li>
</ul>

<p><br /></p>

<ul>
  <li>Program Counter Registers      <br />
java thread가 현재 실행하고 있는 명령(bytecode)의 주소가 program counter register에 저장된다.      <br />
CPU 코어(core)의 address register와 유사한 역할을 한다.      <br />
각 java thread 마다 program counter register를 따로 소유해야 한다.</li>
</ul>

<p><br /></p>

<ul>
  <li>Native stack      <br />
Java 표준 라이브러리의 클래스의 메소드들 중에서, Java가 아니고 C로 구현된 메소드도 있다.      <br />
C로 구현된 메소드를 native method라고 부른다.      <br />
C로 구현된 메소드가 호출될 때 사용될 stack segment를 Native stack 이라고 한다.</li>
</ul>

<p><br /></p>

<h4 id="8-java-thread-와-메모리-영역">8) Java thread 와 메모리 영역</h4>
<p>각 Java thread 마다 따로 소유하는 메모리 영역</p>
<ul>
  <li>Program Counter Register</li>
  <li>Java Stack (지역 변수, 파라미터 변수)</li>
  <li>Native Stack<br />
<br /></li>
</ul>

<p>여러 Java thread들이 공유하는 메모리 영역</p>
<ul>
  <li>Heap (객체, 배열)</li>
  <li>Method Area (상수, static 멤버 변수)</li>
</ul>

<p><br /></p>


  <br />
  <script src="https://utteranc.es/client.js"
        repo="hyerin6/hyerin6.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
  </script>

</div>


    <!-- Documents about icons are here: http://fontawesome.io/icons/ -->
<div class="footer">
  <hr />
  <div class="footer-link">
	
    
    <a href="https://github.com/hyerin6"><i class="fa fa-github" aria-hidden="true"></i></a>
    
	
    
    <a href="mailto:hyerinn6@gmail.com"><i class="fa fa-envelope" aria-hidden="true"></i></a>
    

  </div>
  © 2022 Hyerin. All rights reserved.
</div>

  </div>
</body>
</html>
