<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>제네릭</title>

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css" type="text/css">

  <!-- Font -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css' rel='stylesheet' type='text/css'>
  <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Hyerin Blog" href="/feed.xml" />
  <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>제네릭 | Hyerin Blog</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="제네릭" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="effective java chap5" />
<meta property="og:description" content="effective java chap5" />
<link rel="canonical" href="http://localhost:4000/2021-07-06/chap5/" />
<meta property="og:url" content="http://localhost:4000/2021-07-06/chap5/" />
<meta property="og:site_name" content="Hyerin Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-07-06T00:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="제네릭" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2021-07-06/chap5/","headline":"제네릭","dateModified":"2021-07-06T00:00:00+09:00","datePublished":"2021-07-06T00:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2021-07-06/chap5/"},"@type":"BlogPosting","description":"effective java chap5","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8RJ9ZZ1LSQ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8RJ9ZZ1LSQ', { 'anonymize_ip': false});
</script>


</head>

<body>
  <div class="content-container">
    <header>
  <div class="header-small">
    <a href="http://localhost:4000">Hyerin Blog</a>
  </div>
</header>
<div class="post">
  <div class="post-title">제네릭</div>
  <br />
  <span class="post-date">
    <time>06 Jul 2021</time>
  </span>

  <div class="post-tag">
    <ul>
      
      <li>
        <a href="http://localhost:4000/tags#effective-java">
          <span>effective-java</span>
        </a>
      </li>
      
      
      <li>
        <a href="http://localhost:4000/tags#java">
          <span>java</span>
        </a>
      </li>
      
      
    </ul>
  </div>

  <p>제네릭을 지원하기 전에는 컬렉션에서 객체를 꺼낼 때마다 형변환을 해야 했다.         <br />
제네릭을 사용하면 컬렉션이 담을 수 있는 타입을 컴파일러에게 알려준다.        <br />
컴파일러는 알아서 형변환 코드를 추가할 수 있고 엉뚱한 타입의 객체를 넣으려는 시도를          <br />
컴파일 과정에서 판단하여 더 안전하고 명확한 프로그램을 만들어준다.</p>

<p><br /></p>

<h1 id="26-로-타입은-사용하지-말라">26. 로 타입은 사용하지 말라.</h1>
<p>클래스와 인터페이스 선언에 타입 매개변수가 쓰이면 이를 제네릭 클래스 혹은 제네릭 인터페이스라 한다.     <br />
ex) List 인터페이스는 원소의 타입을 나타내는 타입 매개변수 E를 받는다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>제네릭 클래스 + 제네릭 인터페이스 = 제네릭 타입 
</code></pre></div></div>

<p>각각의 제네릭 타입은 일련의 매개변수화 타입을 정의한다.   <br />
ex) List<String>은 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입이다.</String></p>

<p><br /></p>

<h3 id="raw-type-이란">Raw Type 이란?</h3>

<p>Raw Type은 타입 파라미터가 없는 제네릭 타입을 의미한다.   <br />
다음 예제 코드에서 t가 로 타입 변수이다.  <br />
애초에 제네릭으로 정의되지 않은 클래스나 인터페이스에는 로 타입이 없다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class Trouble&lt;T&gt; {
    public List&lt;String&gt; getStrs() { return Arrays.asList("str"); }
}

public static void main(String[] args) {
    Trouble t = new Trouble();
    
    for(String str : t.getStrs()) { // 컴파일 에러 발생 
        System.out.println(str);
    }
} 
</code></pre></div></div>

<p><br /></p>

<p><strong>Raw Type을 사용하면 왜 컴파일 에러가 발생할까?</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Raw Type의 슈퍼 클래스는 Raw Type이다. 
상속 받지 않은 로 타입의 생성자, 인스턴스 메서드, 필드는 로 타입이다. 
로 타입은 파라미터 T만 지우는게 아니라 슈퍼 클래스의 타입 파라미터, 
해당 클래스에 정의된 모든 타입 파라미터를 지워버린다.   
</code></pre></div></div>

<p>예제에서 <code class="language-plaintext highlighter-rouge">t.getStrs()</code>의 반환 타입이 <code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code>이 아닌 로 타입 <code class="language-plaintext highlighter-rouge">List</code>가 된 것이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private final Collection stamps = ...;
stamps.add(new Coin()); // stamp만 저장하기로 했는데 실수로 coin을 저장함 

for(Iterator i = stamps.iterator(); i.hasNext();); {
    Stamp stamp = (Stamp) i.next(); // ClassCastException을 던진다.
    stamp.cancel();
}
</code></pre></div></div>

<p>오류는 가능한 발생 즉시, 이상적으로는 컴파일 할 때 발견하는 것이 좋다.      <br />
위 코드는 런타임에 오류를 알아챌 수 있는데 이렇게 되면                   <br />
런타임에 문제를 겪는 코드와 원인을 제공하는 코드가 동떨어져 있을 가능성이 커진다.</p>

<p><br /></p>

<p>제네릭을 활용하면 Stamp 인스턴스만 취급한다는 정보가 타입 선언 자체에 녹아든다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private final Collection&lt;Stamp&gt; stamps = ...;

</code></pre></div></div>

<p>이렇게 선언하면 stamps에는 Stamp 인스턴스만 넣어야 함을 컴파일러가 인지하게 된다.  <br />
아무런 경고 없이 컴파일 된다면 의도대로 동작할 것임을 보장한다.   <br />
<strong>컴파일러는 컬렉션에서 원소를 꺼내는 모든 곳에 보이지 않는 형변환을 추가하여 절대 실패하지 않음을 보장한다.</strong></p>

<p><br /></p>

<p>로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다.   <br />
<strong>그렇다면 쓰면 안되는 로 타입을 왜 만들어놓은 걸까?</strong>    <br />
그 이유는 <strong>호환성</strong> 때문이다.</p>

<p>제네릭은 자바 5부터 사용할 수 있다.   <br />
기존 코드를 모두 수용하면서 제네릭을 사용하는 새로운 코드와 맞물려 돌아가게 해야 하기 때문이다.</p>

<p><br /></p>

<p><strong><code class="language-plaintext highlighter-rouge">List&lt;Object&gt;</code>처럼 임의 객체를 허용하는 매개변수화 타입은 괜찮다.</strong> <br />
<strong>로 타입인 <code class="language-plaintext highlighter-rouge">List</code>와 매개변수화 타입인 <code class="language-plaintext highlighter-rouge">List&lt;Object&gt;</code>의 차이는 무엇일까?</strong></p>

<p><code class="language-plaintext highlighter-rouge">List</code>는 제네릭 타입에서 완전히 발을 뺀 것이고,    <br />
<code class="language-plaintext highlighter-rouge">List&lt;Object&gt;</code>는 모든 타입을 허용한다는 의미를 컴파일러에 명확히 전달한 것이다.</p>

<p>매개변수로 <code class="language-plaintext highlighter-rouge">List</code>를 받는 메서드에는 <code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code>을 넘길 수 있지만 <br />
<code class="language-plaintext highlighter-rouge">List&lt;Object&gt;</code>를 받는 메서드에는 넘길 수 없다.  <br />
이는 제네릭의 하위 타입 규칙 때문이다.</p>

<p><code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code> 은 <code class="language-plaintext highlighter-rouge">List</code>의 하위 타입이지만, <code class="language-plaintext highlighter-rouge">List&lt;Object&gt;</code>의 하위 타입은 아니다.   <br />
<code class="language-plaintext highlighter-rouge">List&lt;Object&gt;</code> 같은 매개변수화 타입을 사용할 때와 달리   <br />
List같은 로 타입을 사용하면 타입 안정성을 잃게 된다.   <br />
<br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static void main(String[] args) {
    List&lt;String&gt; strings = new ArrayList&lt;&gt;();
    unsafeAdd(strings, Integer.valueOf(42)); 
    String s = strings.get(0); // 컴파일러가 자동으로 형변환 코드를 넣어준다. 
}

private static void unsafeAdd(List list, Object o) {
    list.add(o);
}
</code></pre></div></div>

<p>위 코드는 컴파일은 되지만 <strong>로 타입</strong>인 <code class="language-plaintext highlighter-rouge">List</code>를 사용하여 다음과 같은 경고가 발생한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>warning: [unchecked] unchecked call to add(E) as a
member of the raw type List
    list.add(0);
            ^
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">strings.get(0)</code>의 결과를 형변환하려 할 때 <code class="language-plaintext highlighter-rouge">ClassCastException</code>을 던진다.  <br />
Integer를 String으로 변환하려 시도한 것이다.  <br />
이 형변환은 컴파일러가 자동으로 만들어준 것이라 보통은 실패하지 않는다.   <br />
하지만 이 경우 컴파일러의 경고를 무시했기 때문에 나타난 결과다.</p>

<p>로 타입인 <code class="language-plaintext highlighter-rouge">List</code>를 매개변수화 타입인 <code class="language-plaintext highlighter-rouge">List&lt;Object&gt;</code>로 바꾼 다음 다시 컴파일해보면,   <br />
다음 오류 메세지지가 출력되며 컴파일조차 되지 않는다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 변경 코드 
unsafeAdd(List&lt;Object&gt; list, Object o) { . . . }

// error
error: incompatible types: List&lt;String&gt; cannot be 
converted to List&lt;Object&gt;
    unsafeAdd(strings, Integer.valueOf(42));
       ^
</code></pre></div></div>

<p>로 타입을 사용하여 잘못된 타입을 사용했을 경우, 해당 에러를 런타임 시에 알게 되지만       <br />
매개변수화 타입을 정의한 제네릭을 사용했을 경우, 해당 오류를 컴파일 즉시 잡아낼 수 있다는 점에서        <br />
제네릭은 안전성을 제공한다.</p>

<p><br /></p>

<p>제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면        <br />
와일드카드(물음표, ?)를 사용하자.</p>

<p>비한정적 와일드카드 타입인 <code class="language-plaintext highlighter-rouge">Set&lt;?&gt;</code>와 로 타입인 <code class="language-plaintext highlighter-rouge">Set</code>은 무슨 차이일까?        <br />
특징을 간단히 말하면 <strong>와일드카드 타입은 안전하고, 로 타입은 안전하지 않다.</strong></p>

<p>로 타입 컬렉션에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽다.     <br />
반면, <code class="language-plaintext highlighter-rouge">Collection&lt;?&gt;</code>에는 (null 외에) 어떤 원소도 넣을 수 없다.</p>

<p><br />    <br />
<br /></p>

<h1 id="27-비검사-경고를-제거하라">27. 비검사 경고를 제거하라.</h1>
<p>제네릭을 사용하기 시작하면 수많은 컴파일러 경고를 보게 될 것이다.</p>

<p>예) <code class="language-plaintext highlighter-rouge">Set&lt;Lark&gt; exaltation = new HashSet();</code></p>

<p>위 코드는 unchecked conversion 경고를 출력한다.   <br />
컴파일러가 알려준 타입 매개변수를 명시하면 경고가 사라지는데  <br />
자바 7부터 지원하는 다이아몬드 연산자(&lt;&gt;)로 해결할 수 있다. <br />
<code class="language-plaintext highlighter-rouge">new HashSet&lt;&gt;();</code></p>

<p>위 예제는 해결하기 쉬운 경고다.  <br />
해결하기 어렵더라도 할 수 있는 한 모든 비검사 경고를 제거하면  <br />
그 코드는 타입 안전성이 보장된다.</p>

<p><br /></p>

<p>만약 경고를 제거할 수 없지만 타입 안전하다고 확신할 수 있다면    <br />
최대한 좁은 범위에 <code class="language-plaintext highlighter-rouge">@SuppressWarnings</code> 어노테이션을 적용하자.   <br />
경고를 숨기기로 한 근거가 있어야 한다.</p>

<p><br />    <br />
<br /></p>


  <br />
  <script src="https://utteranc.es/client.js"
        repo="hyerin6/hyerin6.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
  </script>

</div>


    <!-- Documents about icons are here: http://fontawesome.io/icons/ -->
<div class="footer">
  <hr />
  <div class="footer-link">
	
    
    <a href="https://github.com/hyerin6"><i class="fa fa-github" aria-hidden="true"></i></a>
    
	
    
    <a href="mailto:hyerinn6@gmail.com"><i class="fa fa-envelope" aria-hidden="true"></i></a>
    

  </div>
  © 2022 Hyerin. All rights reserved.
</div>

  </div>
</body>
</html>
