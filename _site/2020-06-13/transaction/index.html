<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Transaction</title>

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css" type="text/css">

  <!-- Font -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css' rel='stylesheet' type='text/css'>
  <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Hyerin Blog" href="/feed.xml" />
  <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Transaction | Hyerin Blog</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Transaction" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="propagation, isolation level" />
<meta property="og:description" content="propagation, isolation level" />
<link rel="canonical" href="http://localhost:4000/2020-06-13/transaction/" />
<meta property="og:url" content="http://localhost:4000/2020-06-13/transaction/" />
<meta property="og:site_name" content="Hyerin Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-13T00:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Transaction" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2020-06-13/transaction/","headline":"Transaction","dateModified":"2020-06-13T00:00:00+09:00","datePublished":"2020-06-13T00:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2020-06-13/transaction/"},"@type":"BlogPosting","description":"propagation, isolation level","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8RJ9ZZ1LSQ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8RJ9ZZ1LSQ', { 'anonymize_ip': false});
</script>


</head>

<body>
  <div class="content-container">
    <header>
  <div class="header-small">
    <a href="http://localhost:4000">Hyerin Blog</a>
  </div>
</header>
<div class="post">
  <div class="post-title">Transaction</div>
  <br />
  <span class="post-date">
    <time>13 Jun 2020</time>
  </span>

  <div class="post-tag">
    <ul>
      
      <li>
        <a href="http://localhost:4000/tags#spring">
          <span>spring</span>
        </a>
      </li>
      
      
    </ul>
  </div>

  <h1 id="transaction">Transaction</h1>

<h3 id="1-배경지식">1. 배경지식</h3>

<h5 id="1-트랜잭션이란">(1) 트랜잭션이란?</h5>

<p>트랜잭션이란 더 이상 나눌 수 없는 단위 작업을 말한다. <br />
작업을 쪼개서 작은 단위로 만들 수 없다는 것은 트랜잭션의 핵심 속성인 원자성을 의미한다.</p>

<p>SQL 명령이 DB에서 실행되는 것을 트랜잭션이라고도 한다.   <br />
별도로 지정하지 않으면 SQL 명령 하나가 실행되는 것이 하나의 트랜잭션이 된다.</p>

<p>SQL 문장 여러개를 묶어서 하나의 트랜잭션을 만들수도 있다.<br />
예를 들어서 운영체제에서 앱이 실행되는 것을 프로세스(process)라고 부르는 것처럼   <br />
DMBS에서 SQL 명령이 실행되는 것은 트랜잭션(transaction)이라고 부른다.</p>

<p>운영체제 프로세스에서 병렬성 문제, 데드락 문제가 발생하는 것과 유사하게 <br />
DB 트랜잭션에서도 병렬성 문제, 데드락 문제가 발생한다.</p>

<p><br /></p>

<h5 id="2-트랜잭션의-속성">(2) 트랜잭션의 속성</h5>

<ul>
  <li>원자성(Atomicity)</li>
</ul>

<p>트랜잭션 내부 작업들이 부분 성공 부분 실패하는 일 없이, 전체 성공하거나 전체 실패하는 것이 보장된다. <br />
예를들어, 자금 이체는 보내는 쪽에서 돈을 빼는 작업과 받는 쪽에 돈을 넣는 작업 중 하나라도 실패하면 안된다.</p>

<p><br /></p>

<ul>
  <li>일관성(Consistency)</li>
</ul>

<p>트랜잭션 실행이 성공적으로 완료되면, 데이터베이스 상태는 모순이 없는 상태가 (consistency) 유지됨이 보장된다. <br />
즉 트랜잭션은 데이터베이스 상태를 모순이 있는 (inconsistent) 상태로 변경할 수 없다.</p>

<p><br /></p>

<ul>
  <li>고립성(Isolation)</li>
</ul>

<p>DB에서 여러 트랜잭션이 동시에 실행되지만, 트랜잭션이 서로 충돌하지 않고, 마치 혼자 실행되는 것과 <br />
같은 환경이 보장된다.</p>

<p>예를들어, 두 트랜잭션이 어떤 레코드를 동시에 쓰려고 할 때. <br />
어떤 트랜잭션이 수정하고 있는 레코드를 다른 트랜잭션이 읽으려고 할 때 <br />
충돌 없이 여러 트랜잭션이 동시에 잘 실행될 수 있음이 보장된다.</p>

<p><br /></p>

<ul>
  <li>지속성(Durability)</li>
</ul>

<p>성공적으로 수행 종료된 트랜잭션이 저장한 데이터는 시스템 장애 등의 이유로 날아가는 일이 없이 <br />
계속 유지됨이 보장된다. 혹시 시스템에 장애가 발생하더라도 DBMS의 백업과 복구 기능을 활용하여, <br />
장애 직전의 상태로 데이터를 전부 복구할 수 있음이 보장된다.</p>

<p><br /></p>

<h3 id="2-구현">2. 구현</h3>

<p>spring 기능을 활용하여 트랜잭션을 구현</p>

<p>(1) application.properties</p>

<div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">spring.aop.proxy-target-class</span><span class="p">=</span><span class="s">true        </span>
</code></pre></div></div>

<p>스프링 트랜잭션 기능을 구현하기 위해서 <br />
<code class="language-plaintext highlighter-rouge">@Transactional</code> 어노테이션을 메소드나 클래스에 붙여줄 경우 <br />
그리고 어노테이션이 사용된 클래스가 부모 interface가 없을 때 <br />
위 설정이 필요하다.</p>

<p><br /></p>

<h1 id="transaction-level">Transaction Level</h1>

<h3 id="트랜잭션-전파-propagation">트랜잭션 전파 (propagation)</h3>

<p>트랜잭션을 시작하거나 기존 트랜잭션에 참여하는 방법을 결정하는 속성이다.   <br />
기존 트랜잭션에 참여한다는 것은 현재 트랜잭션에서 다른 트랜잭션으로 이동할 때를 이야기 한다.</p>

<p>예를들어 AccountService에 트랜잭션이 걸려 있는데 OrderService 에서도 트랜잭션이 걸려 있는 것을 말한다. <br />
같은 클래스는 해당 사항이 없다.</p>

<p>트랜잭션 경계의 시작 지점에서 트랜잭션 전파 속성을 참조해서 해당 범위의 트랜잭션을 어떤 식으로 진행시킬지 정할 수 있다.</p>

<p>다음과 같은 속성으로 설정이 가능하다.</p>

<p><br /></p>

<ul>
  <li>REQUIRED</li>
</ul>

<p>디폴트 속성이며 모든 트랜잭션 매니저가 지원한다.    <br />
미리 시작된 트랜잭션이 있으면 참여하고 없으면 새로 시작한다. <br />
자연스럽고 간단한 트랜잭션 전파 방식이지만 사용해보면 매우 강력하고 유용하다는 사실을 알 수 있다. <br />
하나의 트랜잭션이 시작된 후에 다른 트랜잭션 경계가 설정된 메소드를 호출하면 자연스럽게 같은 트랜잭션으로 묶인다.</p>

<p><br /></p>

<ul>
  <li>SUPPORTS</li>
</ul>

<p>이미 시작된 트랜잭션이 있으면 참여하고 그렇지 않으면 트랜잭션 없이 진행한다. <br />
트랜잭션이 없긴 하지만 해당 경계 안에서 Connection이나 하이버네이트 Session 등을 공유할 수 있다.</p>

<p><br /></p>

<ul>
  <li>MANDATORY</li>
</ul>

<p>REQUIRED와 비슷하게 이미 시작된 트랜잭션이 있으면 참여한다. <br />
반면에 트랜잭션이 시작된 것이 없으면 새로 시작하는 대신 예외를 발생시킨다. <br />
혼자서는 독립적으로 트랜잭션을 진행하면 안 되는 경우에 사용한다.</p>

<p><br /></p>

<ul>
  <li>REQUIRES_NEW</li>
</ul>

<p>항상 새로운 트랜잭션을 시작한다. 이미 진행 중인 트랜잭션이 있으면 트랜잭션을 잠시 보류시킨다. <br />
JTA 트랜잭션 매니저를 사용한다면 서버의 트랜잭션 매니저에 트랜잭션 보류가 가능하도록 설정되어 있어야 한다.</p>

<p><br /></p>

<ul>
  <li>NOT_SUPPORTED</li>
</ul>

<p>트랜잭션을 사용하지 않게 한다. 이미 진행중인 트랜잭션이 있으면 보류시킨다.</p>

<p><br /></p>

<ul>
  <li>NEVER</li>
</ul>

<p>트랜잭션을 사용하지 않도록 강제한다. 이미 진행 중인 트랜잭션도 존재하면 안된다.<br />
만약 있다면 보류시킨다.</p>

<p><br /></p>

<ul>
  <li>NESTED</li>
</ul>

<p>이미 진행중인 트랜잭션이 있으면 중첩 트랜잭션을 시작한다.        <br />
중첩 트랜잭션은 트랜잭션 안에 다시 트랜잭션을 만드는 것이다.      <br />
하지만 독립적인 트랜잭션을 만드는 REQUIRES_NEW와는 다르다.</p>

<p>중첩된 트랜잭션은 먼저 시작된 부모 트랜잭션의 커밋과 롤백에는 영향을 받지만     <br />
자신의 커밋과 롤백은 부모 트랜잭션에게 영향을 주지 않는다.</p>

<p>중첩 트랜잭션은 JDBC 3.0 스펙의 저장포인트(savepoint)를 지원하는 드라이버와  <br />
DataSourceTransactionManager 를 이용할 경우에 적용 가능하다.   <br />
또는 중첩 트랜잭션을 지원하는 일부 WAS의 JTA 트랜잭션 매니저를 이용할 때도 적용할 수 있다.  <br />
유용한 트랜잭션 전파 방식이지만 모든 트랜잭션 매니저에 다 적용 가능한 건 아니므로,  <br />
적용하려면 사용할 트랜잭션 매니저와 드라이버, WAS의 문서를 참조해 보고,  <br />
미리 학습 테스트를 만들어서 검증해봐야 한다.</p>

<p><br /></p>

<h3 id="트랜잭션-격리-isolation">트랜잭션 격리 (isolation)</h3>

<h4 id="1-데이터베이스의-lock">1. 데이터베이스의 Lock</h4>

<h5 id="1-데이터베이스에서-락이란">(1) 데이터베이스에서 락이란?</h5>

<p>동시에 실행되는 여러 트랜잭션이 서로 충돌하는 일이 벌어질 수 있다.    <br />
예를 들어 어떤 트랜잭션에서 UPDATE 명령이 실행되어 어느 레코드를 수정하는 도중에,</p>

<p>다른 트랜잭션에서 그 레코드를 DELETE 해버리면 문제가 발생할 것이다.   <br />
이런 충돌을 피하기 위해서, 트랜잭션에서 데이터를 읽고 쓸 때,  <br />
다른 트랜잭션이 방해하지 못하도록 그 데이터를 잠시 잠그는(lock) 것이 필요하다.    <br />
락(lock)에는 읽기 락과 쓰기 락이 있다</p>

<h5 id="2-읽기-락-rread-lock">(2) 읽기 락 (Rread Lock)</h5>

<p>트랙잭션이 데이터를 읽기 직전에 그 데이터에 읽기 락을 건다.</p>

<p>읽기 락은 여러 개가 중복될 수 있다.   <br />
그래서 동시에 여러 트랜잭션이 같은 데이터를 읽는 것은 가능하다.</p>

<p>읽기 락과 쓰기 락은 중복될 수 없다.   <br />
그래서 어떤 트랜잭션이 데이터를 읽는 중이라서 읽기 락이 걸려 있는 데이터를  <br />
다른 트랜잭션이 수정하는 것은 불가능하다.  <br />
데이터 읽기가 끝나고 읽기 락이 풀리면, 그때 쓰기 락을 걸고 수정하게 된다.</p>

<h5 id="3-쓰기-락-write-lock">(3) 쓰기 락 (Write Lock)</h5>

<p>트랜잭션이 데이터를 쓰기 직전에 그 데이터에 쓰기 락을 건다.</p>

<p>쓰기 락은 여러 개 중복될 수 없다.<br />
그래서 동시에 여러 트랜잭션이 같은 데이터를 수정하는 것은 불가능하다.</p>

<p>읽기 락과 쓰기 락은 중복될 수 없다.<br />
그래서 어떤 트랜잭션이 데이터를 수정하는 중이라서 쓰기 락이 걸려 있는 데이터를 <br />
다른 트랜잭션이 읽는 것은 불가능하다. <br />
데이터 수정이 끝나고 쓰기 락이 풀리면, 그때 읽기 락을 걸고 읽게 된다.</p>

<h5 id="4-쓰기-락의-범위">(4) 쓰기 락의 범위</h5>

<p>트랜잭션이 데이터를 수정할 때 먼저 그 데이터에 자동으로 쓰기 락이 걸리게 된다.     <br />
데이터 수정 전에 쓰기 락이 걸리는 것은 언제나 자동으로 일어난다.    <br />
언제나 트랜잭션이 종료될 때 쓰기 락이 풀린다 (unlock).</p>

<p>즉 쓰기 락은 데이터를 수정하기 직전에 언제나 자동으로 걸리고, <br />
트랜잭션이 종료될 때 쓰기 락이 풀린다.</p>

<h5 id="5-읽기-락의-범위">(5) 읽기 락의 범위</h5>

<p>트랜잭션이 데이터를 읽을 때 먼저 그 데이터에 읽기 락이 자동으로 걸려야 한다.<br />
그런데 읽기 락이 언제나 자동으로 걸리는 것은 아니다.</p>

<p>읽기 락을 하냐 마냐는 Transaction Isolation Level 설정에 따라 다르다.<br />
읽기 락이 언제까지 유지할 것인지도 Transaction Isolation Level 설정에 따라 다르다.</p>

<p><br /></p>

<h4 id="2-transaction-isolation-level">2. Transaction Isolation Level</h4>

<p>Transaction Isolation Level 설정에 따라, <br />
트랜잭션이 데이터를 읽기 전에 읽기 락을 할지 말지 읽기 락을 언제까지 유지할지가 결정된다.</p>

<p>읽기 락을 많이 걸고 오래 유지할 수록 데이터의 안정성은 좋아지지만 성능은 나빠진다. <br />
돈 거래와 같은 중요한 데이터라면 데이터 안정성이 중요하고, <br />
게시판 덧글과 같이 별로 중요하지 않은 데이터라면 성능이 더 중요할 것이다.</p>

<p><br /></p>

<h5 id="1-transaction-isolation-level-설정-명령">(1) Transaction Isolation Level 설정 명령</h5>

<pre><code class="language-mysql">SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED  

SET TRANSACTION ISOLATION LEVEL READ COMMITTED  

SET TRANSACTION ISOLATION LEVEL REPEATABLE READ  

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE 
</code></pre>

<p>위 목록에서 아래의 명령일 수록 읽기 락을 좀 더 많이 건다.</p>

<p>Transaction Isolcation Level을 설정하는 명령을 실행하지 않았다면, <br />
디폴트 상태는 다음과 같다.</p>

<ul>
  <li>
    <p>Oracle : READ COMMITTED</p>
  </li>
  <li>
    <p>SQL Server : READ COMMITTED</p>
  </li>
  <li>
    <p>MySQL : REPEATABLE READ</p>
  </li>
</ul>

<p><br /></p>

<h5 id="2-read-uncommitted">(2) Read Uncommitted</h5>

<p>읽기 락을 전혀 하지 않는다. 그래서 가장 빠르다.</p>

<p><strong>Dirty Reads 문제 발생</strong></p>

<p>읽기 락을 전혀 하지 않기 때문에, 다른 트랜잭션이 수정하고 있어서 쓰기 락이 걸려 있는 데이터도 읽을 수 있다.   <br />
그래서 게시글 본문이 반쯤 저장된 상태에서 그 게시글 레코드를 읽는 것이 가능하다.</p>

<p>이렇게 완전하지 않고 반쯤 수정된 데이터가 읽혀질 수 있는 문제를 Dirty Reads 문제라고 부른다.</p>

<p>읽기 락을 하지 않기 때문에, 어떤 트랜잭션이 읽고 있는 중인 데이터를 <br />
다른 트랜잭션이 쓰기 락을 걸고 수정하거나 삭제할 수도 있다.</p>

<p>Read Uncommitted 레벨에서는 Dirty Reads 문제가 발생할 수 있다.</p>

<p>이 문제를 피하려면, Transaction Isolation Level 을 다음 단계인 Read Committed로 올려야 한다.</p>

<p><br /></p>

<h5 id="3-read-committed">(3) Read Committed</h5>

<p>데이터를 읽기 직전에 언제나 읽기 락을 한다.    <br />
그리고 그 SQL 문장이 끝나자 마자 읽기 락을 푼다.    <br />
즉 읽기 락을 SQL 문장 하나 단위로만 유지한다.</p>

<p>읽기 락을 걸고 데이터를 읽기 때문에,  <br />
그리고 읽기 락이 걸려 있는 데이터에 쓰기 락을 걸 수는 없기 때문에,  <br />
읽는 중인 데이터를 다른 트랜잭션이 수정할 수 없다.  <br />
따라서 Dirty Reads 문제는 발생하지 않는다.</p>

<p>Transaction Isolcation Level을 설정하는 명령을 실행하지 않았다면,  <br />
이것이 디폴트 상태이다.</p>

<p><strong>Non-repeatable Reads 문제 발생</strong></p>

<p>Read Committed 단계에서는 Dirty Reads 문제는 해결 되었지만,<br />
모든 문제가 다 해결된 것은 아니다.<br />
미묘한 Non-repeatable Reads 문제가 남아있다.</p>

<p>하나의 트랜잭션에서 어떤 데이터를 처음 읽을 때와 나중에 읽을 때 값이 달라져서   <br />
문제가 되는 상황을 Non-Repeatable Reads 문제라고 부른다.</p>

<p>Non-Repeatable Reads 문제를 피하려면  <br />
다른 트랜잭션이 사이에 끼어 들어와서 데이터를 수정하지 못하게 막아야 한다. <br />
그러러면 읽기 락을 좀 더 열심히 걸어야 한다.</p>

<p>Non-Repeatable Reads 문제를 피하려면 <br />
Transaction Isolation Level 을 다음 단계인 Repeatable Read 단계로 올려야 한다.</p>

<p><br /></p>

<h5 id="4-repeatable-read">(4) Repeatable Read</h5>

<p>데이터를 읽기 직전에 읽기 락을 건다. <br />
그리고 읽기 락을 트랜잭션 끝날 때까지 유지해서 <br />
다른 트랜잭션이 사이에 끼어 들어와서 데이터를 수정하지 못하게 막는다.</p>

<p><strong>Non-repeatable Reads 문제 해결</strong></p>

<p>읽기 락이 걸려 있는 데이터에 다른 트랜잭션이 쓰기 락을 걸 수 없지만,    <br />
읽기 락을 건 바로 그 트랜잭션은, 자신이 걸었던 읽기 락을 쓰기 락으로 변경하는 것이 가능하다.</p>

<p><strong>Phantom Reads 문제 발생</strong></p>

<p>Repeatable Read 단계에서 Non-repeatable Reads 문제는 해결 되었지만<br />
모든 문제가 다 해결된 것은 아니다.<br />
아주 미묘한 Phantom Reads 문제가 남아있다.</p>

<p>예를 들어 수강 신청에서 <br />
절차1) 먼저 강좌의 수강 레코드 수를 조회하여 최대 수강 인원 수 보다 크거나 같다면, <br />
그 강좌의 수강 인원이 꽉찬 것이므로 종료.</p>

<p>절차2) 그렇지 않다면 수강 레코드 삽입(insert)</p>

<p>위와 같은 순서로 구현했을 때,  <br />
절차1에서 읽은 수강 레코드들에 읽기 락이 걸리고 트랜잭션이 끝날 때가지 유지된다. <br />
그 트랜잭션이 끝날 때가지 읽기 락이 걸려 있는 수강 레코들은 수정 될 수 없도록 보호되지만, <br />
새 수강 레코드가 삽입되는 것은 가능하다.  <br />
그래서 절차1과 절차2 사이에 다른 트랜잭션이 그 강좌에 새 수강 레코드를 삽입할 수 있다.</p>

<p>절차1에서 강좌의 수강 레코드 수를 조회할 때는 최대 수강 인원 수 보다 작았는데,<br />
막상 절차2를 실행할 때는 최대 수강 인원 수와 수강 레코드 수가 같을 수 있다.<br />
절차1과 절차2 사이에 다른 트랜잭션이 수강 레코드를 등록할 수 있기 때문이다.</p>

<p>절차1과 절차2에서 조회한 수강 레코드 수가 동일하려면,   <br />
절차1과 절차2 사이에 다른 트랜잭션이 그 강좌에 수강 레코드를 등록하지 못하게 막아야 한다.</p>

<p>이렇게 막는 것은 조금 복잡한 읽기 락(lock)이 필요하다.</p>

<p>Phantom Reads 문제를 피하려면 <br />
좀 더 복잡한 읽기 락을 걸어야 한다.  <br />
Transaction Isolation Level 을 다음 단계인 Serializable 단계로 올려야 한다.</p>

<p><br /></p>

<h5 id="5-serializable">(5) Serializable</h5>

<p>Phantom Reads 문제를 피하기 위해 좀 더 복잡한 읽기 락을 건다.  <br />
그리고 트랜잭션 끝날 때까지 읽기 락을 유지한다.</p>

<p>테이블에 읽기 락을 걸거나, 테이블 인덱스에 읽기 락을 걸거나, <br />
WHERE 절 조건식으로 읽기 락을 걸기도 한다.</p>

<p>테이블에 읽기 락이 걸리면, 그 테이블에 대한 모든 수정(insert, update, delete)은 막힌다.    <br />
데이블 인덱스에 읽기 락이 걸리면, 그 인덱스에 변화를 초래하는 수정(insert, update, delete)은 막힌다.  <br />
WHERE 절 조건식으로 읽기 락이 걸리면, WHERE 절 조건식의 true/false 값이 변할 만한 수정(insert, update, delete)은 막힌다.</p>

<p><strong>Phantom Reads 문제 해결</strong></p>

<p>수강 신청에서 절차를 다시 생각해 보자.  <br />
절차1) 먼저 강좌의 수강 레코드 수를 조회하여 최대 수강 인원 수 보다 크거나 같다면,     <br />
그 강좌의 수강 인원이 꽉찬 것이므로 종료.</p>

<p>절차2) 그렇지 않다면 수강 레코드 삽입(insert)</p>

<p>강좌의 수강 레코드 수 조회 SQL 문은 다음과 같은 형태일 것이.</p>

<pre><code class="language-mysql">SELECT COUNT(*) FROM 수강 WHERE lectureId = #{lectureId}   
</code></pre>

<p>절차1에서 읽은 강좌 레코드 수를 조회하는 WHERE 절의 조건식에 읽기 락이 걸린다. <br />
위 WHERE 조건식의 값이, 어떤 명령의 실행 전과 후에 달라지다면, 락에 의해서 그 명령의 실행은 막힌다.  <br />
위 WHERE 조건식이 true인 레코드를 delete 하는 것도 막힌다. <br />
위 WHERE 조건식이 true인 레코드를 insert 하는 것도 막힌다.</p>

<p>따라서 절차1과 절차2 사이에 다른 레코드가 끼어 들어와서 그 강좌에 새 수강 레코드를 삽입할 수 없다.</p>

<p>Serializable 단계는 모든 읽기 문제가 다 해결된 단계이다.</p>

<p><br /></p>

<h1 id="요약">요약</h1>

<p><strong>read uncommitted</strong></p>

<p>어떤 트랜잭션이 수정한 내용이 아직 commit 되기 전부터,</p>

<p>다른 트랜잭션들에게 그 값이 보임. (dirty read 문제)</p>

<p><br /></p>

<p><strong>read committed</strong></p>

<p>어떤 트랜잭션이 수정한 내용이 commit 된 이후에만.</p>

<p>다른 트랜잭션들에게 그 값이 보임. (dirty read 해결됨)</p>

<p>어떤 트랜잭션이 한 번 읽은 레코드를, 트랜잭션 실행 도중 다시 읽었을 때,</p>

<p>그 사이에 다른 트랜잭션이 그 레코드를 수정하고 commit 했다면,</p>

<p>다시 읽은 값은 처음 읽은 값과 달라진다. (nonrepeatable read 문제)</p>

<p><br /></p>

<p><strong>repeatable read</strong></p>

<p>어떤 트랜잭션이 한 번 읽은 레코드를, 트랜잭션 실행 도중 다시 읽었을 때,</p>

<p>그 사이에 다른 트랜잭션이 그 레코드를 수정하고 commit 했더라도,</p>

<p>처음 읽은 값과 다시 읽은 값이 동일함이 보장된다. (nonrepeatable read 해결됨)</p>

<p>어떤 트랜잭션이 아직 읽지 않은 레코드를,</p>

<p>다른 트랜잭션이 수정하는 것이 허용된다.</p>

<p>예를 들어, 어떤 소프트웨어공학과 학생 수를 세기 위해</p>

<p>소프트웨어공학과 학생 레코드들을 읽으면,</p>

<p>그 사이에 다른 트랜잭션이 그 레코드를 수정하고 commit 했더라도,</p>

<p>처음 읽은 값과 다시 읽은 값이 동일함이 보장된다.</p>

<p>하지만,</p>

<p>다른 트랜잭션이 소프트웨어공학과 학생 레코드가 새로 추가하고 commit 한 후에,</p>

<p>다시 소프트웨어공학과 학생 수를 세면, 처음 세었을 때 보다 1 증가했을 것이다.</p>

<p>(phantom read 문제)</p>

<p><br /></p>

<p><strong>serializable</strong></p>

<p>phantom read 문제도 해결됨.</p>

<p><br /></p>



  <br />

  <hr />

  <br />
  <script src="https://utteranc.es/client.js"
        repo="hyerin6/hyerin6.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
  </script>

</div>


    <!-- Documents about icons are here: http://fontawesome.io/icons/ -->
<div class="footer">
  <hr />

  <div class="footer-link">
    
    <a href="https://github.com/hyerin6"><i class="fa fa-github" aria-hidden="true"></i></a>
    
	
    
    <a href="mailto:hyerinn6@gmail.com"><i class="fa fa-envelope" aria-hidden="true"></i></a>
    
  </div>
  © 2022 Hyerin. All rights reserved.
</div>

<br />
<div class="footer">
    <a style="text-align: center;" href="https://hits.seeyoufarm.com">
      <img style="text-align: center;" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fhyerin6.github.io&count_bg=%23010101&title_bg=%23070707&icon=&icon_color=%23E7E7E7&title=visitors&edge_flat=false"/>
    </a>
</div>
  </div>
</body>
</html>
