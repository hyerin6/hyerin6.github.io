<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>액티브 유저 3억명 이상인 SNS를 개발한다면?</title>

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css" type="text/css">

  <!-- Font -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css' rel='stylesheet' type='text/css'>
  <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Hyerin Blog" href="/feed.xml" />
  <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>액티브 유저 3억명 이상인 SNS를 개발한다면? | Hyerin Blog</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="액티브 유저 3억명 이상인 SNS를 개발한다면?" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="(feat.트위터)" />
<meta property="og:description" content="(feat.트위터)" />
<link rel="canonical" href="http://localhost:4000/2021-11-17/sns/" />
<meta property="og:url" content="http://localhost:4000/2021-11-17/sns/" />
<meta property="og:site_name" content="Hyerin Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-11-17T00:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="액티브 유저 3억명 이상인 SNS를 개발한다면?" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2021-11-17/sns/","headline":"액티브 유저 3억명 이상인 SNS를 개발한다면?","dateModified":"2021-11-17T00:00:00+09:00","datePublished":"2021-11-17T00:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2021-11-17/sns/"},"@type":"BlogPosting","description":"(feat.트위터)","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8RJ9ZZ1LSQ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8RJ9ZZ1LSQ', { 'anonymize_ip': false});
</script>


</head>

<body>
  <div class="content-container">
    <header>
  <div class="header-small">
    <a href="http://localhost:4000">Hyerin Blog</a>
  </div>
</header>
<div class="post">
  <div class="post-title">액티브 유저 3억명 이상인 SNS를 개발한다면?</div>
  <br />
  <span class="post-date">
    <time>17 Nov 2021</time>
  </span>

  <div class="post-tag">
    <ul>
      
      <li>
        <a href="http://localhost:4000/tags#redis">
          <span>redis</span>
        </a>
      </li>
      
      
      <li>
        <a href="http://localhost:4000/tags#spring">
          <span>spring</span>
        </a>
      </li>
      
      
    </ul>
  </div>

  <p><br /></p>

<p>SNS 프로젝트는 현재 다음과 같은 서버 구조를 갖고 있다.</p>

<p><img width="826" alt="스크린샷 2021-11-17 오후 3 23 18" src="https://user-images.githubusercontent.com/33855307/142145906-0e473d16-7969-4f26-89ea-c33a23ef4936.png" /></p>

<p>메시지큐, 캐싱, 로드밸런싱 등 성능 개선을 위해 노력했고 실제로 성능이 개선되기는 했으나</p>

<p>프리티어로 구성한 서버라 한계가 있었고 특히 좋아요, 타임라인 기능 개선이 쉽지 않았다.</p>

<p>실제로 3억명 이상의 액티브 유저를 보유한 트위터의 타임라인 시스템을 알아보고</p>

<p>현재 프로젝트에 적용해볼 수 있는 부분이 있다면 학습해보고 적용해보기로 했다.</p>

<p><br />
<br /></p>

<h2 id="sns-특징">SNS 특징</h2>

<p>트위터는 다음과 같은 통계를 내고 있다.</p>

<ul>
  <li>액티브 유저 3억명 이상</li>
  <li>초당 600개 이상의 트윗 생성, 초당 60만건 이상의 조회 발생</li>
</ul>

<p><br /></p>

<p>위 통계는 트위터 기준이지만 대부분 SNS는 다음과 같은 특징을 갖고 있다.</p>

<ul>
  <li>읽기 요청이 엄청나다.</li>
  <li>Eventually Consistent(언젠가는 동기화됨을 보장) 특성이 있기 때문에 약간의 딜레이는 허용한다.</li>
  <li>데이터 저장소 비용을 최적화해야 한다.</li>
</ul>

<p><br /></p>

<p>쓰기 요청은 메시지큐를 적용했기 때문에 약간의 딜레이가 있을 수 있지만</p>

<p>데이터가 유실되지 않고 많은 요청을 받을 수 있게 개선된 상태이다.</p>

<p>문제는 읽기 요청이다. 캐싱을 적용하긴 했지만 읽기 요청이 엄청나기 때문이다.</p>

<p><br />
<br /></p>

<h2 id="팔로워-수에-따른-타임라인-구현">팔로워 수에 따른 타임라인 구현</h2>

<p>트위터는 새로운 트윗을 작성한 트위터의 팔로워 수에 따라 타임라인 캐시를 만드는 방식이 다르다고 한다.</p>

<p><img width="826" src="https://user-images.githubusercontent.com/33855307/142159942-733c3fff-ef39-471f-b4e3-fa96b51f26c5.jpeg" /></p>

<p>출처: <a href="https://medium.com/@narengowda/system-design-for-twitter-e737284afc95">https://medium.com/@narengowda/system-design-for-twitter-e737284afc95</a></p>

<p><br /></p>

<h3 id="1-팔로우-수가-많은-셀럽">1) 팔로우 수가 많은 셀럽</h3>

<p><img width="826" src="https://user-images.githubusercontent.com/33855307/142160332-b5eefab8-0d34-44ef-9e0c-29ffcf9d56fe.jpeg" /></p>

<p>유명 트윗터인 경우 팔로워가 8000만명이 넘는 경우도 있다고 한다.</p>

<p>위 사진은 많은 팔로워 수로 유명한 배우의 SNS이다.</p>

<p>2,361만명으로 이 경우, 팬아웃 방식을 사용하는 것은 시스템 부담이 있다.</p>

<p>이 경우, 타임라인 조회 요청 시, 일반 타임라인 캐시에 유명 트윗터의 트윗을 합쳐주는 방식을 사용해야한다.</p>

<p>현재 프로젝트에서도 사용하는 방식이다.</p>

<p>쿼리는 다음과 같다.</p>

<pre><code class="language-mysql">SELECT 
        * 
    
FROM 
        post
        JOIN USER ON post.user_id = user.id 
        JOIN follows ON follows.following_id = user.id 
    
WHERE 
        follows.follower_id = user_id
</code></pre>

<p>RDB에서 데이터를 조회한다.</p>

<p><br />
<br /></p>

<h3 id="2-일반-팔로워">2) 일반 팔로워</h3>

<p>매번 Post 테이블을 search하기엔 부담되기 때문에 일반 사용자들의</p>

<p>트위터 쓰기 요청이 들어오면, 팔로워의 타임라인 캐시에 새로운 트윗 아이디를 추가해주는 방식이다.</p>

<p>이를 fan-out 방법이라고 한다.</p>

<p><br /></p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 사용자가 게시글 작성을 요청한다. 
2. 게시글 요청은 로드밸런싱을 통해 서버로 전달된다. 
3. 서버는 DB와 Cache 저장소에 해당 데이터를 저장한다. 
4. 서버는 cache 저장소에서 해당 유저를 팔로우 한 사람의 유저 정보들을 가져 온다.
5. 해당(팔로우한 유저들) 유저들의 in-memory(Redis)에 해당 데이터를 저장한다.
6. 트윗을 작성한 유저를 팔로우한 유저들은 타임라인에서 해당 트윗을 볼 수있다.


* 모든 팔로우 유저의 in-memory에 데이터를 저장하지 않고 
2주내로 접속한 액티브 유저들의 타임라인에만 저장한다. 
</code></pre></div></div>

<p>타임라인 조회 시 DB를 접근할 필요 없이 해당 유저의 in memory 데이터에서 타임라인 데이터를 가져오면 된다.</p>

<p><br /></p>

<p>대용량 트래픽을 감당하는 시스템에 대해 알아봤다.</p>

<p>현재 개발중인 SNS 프로젝트에서 사용자를 이렇게 구분할 수 없어서 DB에서 조회한 데이터를</p>

<p>캐싱처리해서 DB에 읽기 요청을 최대한 줄이는 방법으로 구현했다.</p>

<p><br />
<br /></p>

<h2 id="좋아요-기능">좋아요 기능</h2>

<p>현재 많은 SNS에서 좋아요 수를 보여주는 기능을 없애는 분위기지만 좋아요 기능은 아직 남아있다.</p>

<p>좋아요를 요청하고 취소하는 작업은 자주 발생하기 때문에 개선할 부분이라고 생각하고 개선 방법을 찾아봤다.</p>

<p><img width="826" src="https://user-images.githubusercontent.com/33855307/142199917-2773984e-7c14-4406-9c15-373e2bef2b70.png" /></p>

<p>가장 유명한 방법은 Redis의 Set을 이용해 중복 검사를 따로 하지 않고</p>

<p>RDB에는 Spring Batch를 이용하여 bulk insert로 데이터를 저장하는 것이다.</p>

<p>redis와 spring batch를 학습해보고 적용해보면 좋을 것 같다.</p>

<p><br />
<br /></p>

<h3 id="참고">참고</h3>

<ul>
  <li>
    <p><a href="https://medium.com/garimoo/%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%A0%88%EB%94%94%EC%8A%A4-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-02-f1029893e263">개발자를 위한 레디스 튜토리얼 02</a></p>
  </li>
  <li>
    <p><a href="https://medium.com/garimoo/%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%A0%88%EB%94%94%EC%8A%A4-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-04-17256c55493d">개발자를 위한 레디스 튜토리얼 04</a></p>
  </li>
  <li>
    <p><a href="https://medium.com/@narengowda/system-design-for-twitter-e737284afc95">System design for Twitter</a></p>
  </li>
  <li>
    <p><a href="https://www.slideshare.net/mariano/raffi-krikorian-twitter-timelines-at-scale/10-TimelineServiceWrite_APIFanoutRedisRedisTimelineCacheRedisTweetyPieGizmoduck">Timeline Service Write API Fanout</a></p>
  </li>
  <li>
    <p><a href="https://www.youtube.com/watch?v=wYk0xPP_P_8">Twitter system design, twitter Software architecture, twitter interview questions</a></p>
  </li>
  <li>
    <p><a href="https://medium.com/@Pinterest_Engineering/building-a-follower-model-from-scratch-b51a08c5b54e">Building a follower model from scratch</a></p>
  </li>
</ul>

<p><br /></p>


  <br />
  <script src="https://utteranc.es/client.js"
        repo="hyerin6/hyerin6.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
  </script>

</div>


    <!-- Documents about icons are here: http://fontawesome.io/icons/ -->
<div class="footer">
  <hr />
  <div class="footer-link">
	
    
    <a href="https://github.com/hyerin6"><i class="fa fa-github" aria-hidden="true"></i></a>
    
	
    
    <a href="mailto:hyerinn6@gmail.com"><i class="fa fa-envelope" aria-hidden="true"></i></a>
    

  </div>
  © 2022 Hyerin. All rights reserved.
</div>

  </div>
</body>
</html>
