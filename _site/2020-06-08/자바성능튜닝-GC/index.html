<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>GC는 언제 발생할까?</title>

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css" type="text/css">

  <!-- Font -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css' rel='stylesheet' type='text/css'>
  <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Hyerin Blog" href="/feed.xml" />
  <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>GC는 언제 발생할까? | Hyerin Blog</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="GC는 언제 발생할까?" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="자바 성능 튜닝 이야기 story 17" />
<meta property="og:description" content="자바 성능 튜닝 이야기 story 17" />
<link rel="canonical" href="http://localhost:4000/2020-06-08/%EC%9E%90%EB%B0%94%EC%84%B1%EB%8A%A5%ED%8A%9C%EB%8B%9D-GC/" />
<meta property="og:url" content="http://localhost:4000/2020-06-08/%EC%9E%90%EB%B0%94%EC%84%B1%EB%8A%A5%ED%8A%9C%EB%8B%9D-GC/" />
<meta property="og:site_name" content="Hyerin Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-08T00:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="GC는 언제 발생할까?" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2020-06-08/%EC%9E%90%EB%B0%94%EC%84%B1%EB%8A%A5%ED%8A%9C%EB%8B%9D-GC/","headline":"GC는 언제 발생할까?","dateModified":"2020-06-08T00:00:00+09:00","datePublished":"2020-06-08T00:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2020-06-08/%EC%9E%90%EB%B0%94%EC%84%B1%EB%8A%A5%ED%8A%9C%EB%8B%9D-GC/"},"@type":"BlogPosting","description":"자바 성능 튜닝 이야기 story 17","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8RJ9ZZ1LSQ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8RJ9ZZ1LSQ', { 'anonymize_ip': false});
</script>


</head>

<body>
  <div class="content-container">
    <header>
  <div class="header-small">
    <a href="http://localhost:4000">Hyerin Blog</a>
  </div>
</header>
<div class="post">
  <div class="post-title">GC는 언제 발생할까?</div>
  <br />
  <span class="post-date">
    <time>08 Jun 2020</time>
  </span>

  <div class="post-tag">
    <ul>
      
      <li>
        <a href="http://localhost:4000/tags#java">
          <span>java</span>
        </a>
      </li>
      
      
    </ul>
  </div>

  <p><br /></p>

<h2 id="gc란">GC란?</h2>

<p>자바에서 메모리 관리를 누가 해야 하는가에 대한 생각을 해보자.   <br />
자바에서 메모리를 GC라는 알고리즘을 통하여 관리하기 때문에, <br />
개발자가 메모리를 처리하기 위한 로직을 만들 필요가 없고 만들어서는 안된다.</p>

<p>Garbage Collection 은 말그대로 쓰레기를 정리하는 작업이다.     <br />
자바 프로그래밍을 할 때 쓰레기란 어떤 것일까?   <br />
자바에서 쓰레기는 객체이다. 하나의 객체는 메모리를 점유하고, 필요하지 않으면 메모리에서 해제되어야 한다.     <br />
<br /></p>

<p>메로리 점유는 다음과같이 쉽게 할 수 있다.   <br />
이러한 코드에서는 a라는 객체가 만들어쟈 메모리의 한 부분을 점유하게 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">();</span>     
</code></pre></div></div>

<p>그럼 다음의 코드를 보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">String</span> <span class="nf">makeQuery</span><span class="o">(</span><span class="nc">String</span> <span class="n">code</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">queryPre</span> <span class="o">=</span> <span class="s">"Select * from table_a where a='"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">queryPost</span> <span class="o">=</span> <span class="s">"' order by c"</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">queryPre</span> <span class="o">+</span> <span class="n">code</span> <span class="o">+</span> <span class="n">queryPost</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 메서드를 호출한 후 수행이 완료되면 queryPre 객체와 queryPost 객체는 더 이상 필요가 없는 객체, <br />
즉 쓰레기가 된다.   <br />
이 쓰레기 객체를 효과적으로 처리하는 작업을 GC라고 한다.</p>

<p><br />      <br />
<br /></p>

<h2 id="자바의-runtime-data-area는-이렇게-구성된다">자바의 Runtime data area는 이렇게 구성된다.</h2>

<ul>
  <li>PC 레지스터</li>
  <li>JVM 스택</li>
  <li>힙(Heap)</li>
  <li>메서드 영역</li>
  <li>런타임 상수(constant) 풀</li>
  <li>네이티브 메서드 스택</li>
</ul>

<p>이 영역 중에서도 GC가 발생하는 부분이 바로 힙 영역이다.    <br />
거꾸로 말하면, 나머지는 GC 대상이 아니라는 것이다.</p>

<p>다음은 이 영역들을 그림으로 나타낸 것이다.</p>

<p><br /> 
<img width="525" alt="스크린샷 2020-06-08 오후 2 59 29" src="https://user-images.githubusercontent.com/33855307/83997153-b5e49100-a998-11ea-80f3-2efa338380c5.png" />          <br />
<br /></p>

<ul>
  <li>클래스 로더 서브 시스템 : 클래스나 인터페이스를 JVM으로 로딩하는 기술을 수행</li>
  <li>실행 엔진 : 로딩된 클래스의 메서드들에 포함되어 있는 모든 인스트럭션 정보를 실행한다.</li>
</ul>

<p>그림은 복잡해 보이지만, 자바의 메모리 영역은 단순하게 ‘Heap 메모리’와 ‘Non-heap 메모리’로 나뉜다.   <br />
<br /></p>

<ol>
  <li>
    <p>Heap 메모리 <br />
클래스 인스턴스, 배열이 이 메모리에 쌓인다. <br />
이 메모리는 ‘공유 메모리’라고도 부르며 여러 스레드애서 공유하는 데이터들이 저장되는 메모리다.    <br />
<br /></p>
  </li>
  <li>
    <p>Non-heap 메모리  <br />
이 메모리는 자바의 내부 처리를 위해서 필요한 영역이다. <br />
주된 영역이 바로 메서드 영역이다.</p>
  </li>
</ol>

<ul>
  <li>메서드 영억: 메서드 영억은 모든 JVM 스레드에서 공유한다.         <br />
이 영역에서 공유되는 데이터들은 다음과 같다.           <br />
런타임 상수 풀, 필드 정보에는 메서드 데이터, 메서드와 생성자 코드가 있다. <br />
<br /></li>
  <li>JVM 스택     <br />
스레드가 시작할 때 JVM 스택이 생성된다.     <br />
이 스택에는 메서드가 호출되는 정보인 프레임이 저장된다.  <br />
지역변수와 임시 결과, 메서드 수행과 리턴에 관련된 정보들도 포함된다.     <br />
<br /></li>
  <li>네이티브 메서드 스택   <br />
자바 코드가 아닌 다른 언어로된 코드들이 실행하게 될 때의 스택 정보를 관리한다.    <br />
<br /></li>
  <li>PC 레지스터     <br />
자바의 스레드들은 각각의 pc(Program Counter) 레지스터를 갖는다. <br />
네이티브한 코드를 제외한 모든 자바 코드들이 수행될 때 JVM의 인트럭션 주소를 pc 레지스터에 보관한다.</li>
</ul>

<p>여기서 Heap 영역과 메서드 영역은 JVM이 시작될 때 생성된다.</p>

<p><br />        <br />
<br /></p>

<h2 id="gc의-원리">GC의 원리</h2>
<p>GC 작업을 하는 가비지 콜렉터는 다음의 역할을 한다.</p>

<ul>
  <li>메모리 할당</li>
  <li>사용 중인 메모리 인식</li>
  <li>사용하지 않는 메모리 인식</li>
</ul>

<p>사용하지 않는 메모리를 인식하는 작업을 수행하지 않으면, <br />
할당한 메모리 영역이 꽉 차서 JVM에 행(Hang)이 걸리거나 더 많은 메모리를 할당하려는 현상이 발생할 것이다.</p>

<p>JVM의 메모리는 여러 영역으로 나뉘는데, GC와 관련된 부분은 힙이다.    <br />
따라서 가비지 콜렉터가 인식하고 할당하는 자바의 힙 영역에 대해서 알아보자.</p>

<p><a href="https://hyerin6.github.io/2020-03-23/GC(2)/">힙 영역 구조 참고</a></p>

<ul>
  <li>Young 영역에서 Old 영역으로 넘어가는 객체 중에서 Survivor 영억을 거치지 않고 바로 Old 영역으로 이동하는 객체가 있을 수 있는데,<br />
객체의 크기가 아주 큰 경우이다.  <br />
Survivor 영역의 크키가 16MB 라고 가정했을 때 20MB를 점유하는 객체는 Survivor 영역으로 옮겨갈 수 없다.  <br />
이런 객체들은 바로 Old 영역으로 이동하게 된다.</li>
</ul>

<p><br />      <br />
<br /></p>

<h2 id="gc의-종류">GC의 종류</h2>
<p>크게 두 가지 타입으로 나뉜다.</p>

<ul>
  <li>마이너GC : Young 영역에서 발생하는 GC</li>
  <li>메이저GC : Old 영역이나 Perm 영역에서 발생하는 GC</li>
</ul>

<p>이 두 가지 GC가 어떻게 상호작용하느냐에 따라서 GC 방식에 차이가 나며, 성능에도 영향을 준다.    <br />
<br /></p>

<p>GC가 발생하거나 객체가 각 영역에서 다른 영역으로 이동할 때 애플리케이션의 병목이 발생하면서 성능에 영향을 주게 된다.  <br />
그래서 핫 스팟 JVM 에서는 스레드 로컬 할당 버퍼라는 것을 사용한다. <br />
이를 통하여 각 스레드별 메모리 버퍼를 사용하면 다른 스레드에 영향을 주지 않는 메모리 할당 작업이 가능해 진다.</p>

<p><br />      <br />
<br /></p>

<h2 id="5가지-gc-방식">5가지 GC 방식</h2>
<p>JDK 7 이상에서 지원하는 GC 방식에는 다섯 가지가 있다.</p>

<p>Java VM(Virtual Machine) 내부에서 garbage collection 작업을 수행하는 엔진을 garbage collector라고 부른다.   <br />
Java VM 내부에 garbage collector가 여러 개 구현되어 있고,    <br />
Java VM을 실행할 때 command line parameter로 garbage collector를 선택할 수 있다.</p>

<p><strong>[참고]</strong>                   <br />
5가지 방식 자세한 설명 : <a href="https://hyerin6.github.io/2020-03-23/GC(2)/">https://hyerin6.github.io/2020-03-23/GC(2)/</a>      <br />
GC 과정에 대한 Naver D2 글 : <a href="https://d2.naver.com/helloworld/1329">https://d2.naver.com/helloworld/1329</a></p>

<p><br /></p>

<h3 id="1-serial-gc-시리얼-콜렉터">1. Serial GC 시리얼 콜렉터</h3>
<p>mark-sweep-compact 알고리즘을 사용해 Old 영역의 GC를 수행한다. <br />
첫 단계에서 Old 영역에 살아있는 객체를 식별하고 힙의 앞부분부터 확인하여 살아있는 객체는 남긴다. <br />
마지막 단계에서 각 객체가 연속되게 쌓이도록 살아있는 객체들을 한 곳으로 모은다.</p>

<p><strong>적은 메모리와 CPU 코어 개수가 적을 때 적합한 방식이다.</strong>            <br />
그러나 운영 서버에서 절대 사용하면 안 되는 방식이 Serial GC다.         <br />
Serial GC는 데스크톱의 CPU 코어가 하나만 있을 때 사용하기 위해서 만든 방식이다.         <br />
Serial GC를 사용하면 애플리케이션의 성능이 많이 떨어진다.</p>

<p><br /></p>

<h3 id="2-parallel-gc-패러랠-콜렉터-병렬-콜렉터">2. Parallel GC 패러랠 콜렉터 (병렬 콜렉터)</h3>
<p>스루풋 콜렉터(throughtput collector)라고도 부른다.    <br />
시리얼 콜렉터와 기본적인 알고리즘은 같은데 이 방식은 Young 영역을 병렬로 처리한다.</p>

<p>이 방식의 목표는 다른 CPU가 대기 상태로 남아있는 것을 최소화하는 것이다. <br />
시리얼 GC는 GC를 처리하는 스레드가 하나이지만, Parallel GC는 여러개이기 때문에  <br />
Parallel GC는 GC의 부하를 줄이고 빠르게 처리량을 증가시킬 수 있다.</p>

<p><strong>메모리가 충분하고 코어 개수가 많을 때 유리하다.</strong></p>

<p><br /></p>

<h3 id="3-parallel-old-gc">3. Parallel Old GC</h3>
<p>Parallel GC와는 Old 영역의 GC 과정만 다르다.        <br />
이 방식은 Mark-Summary-Compact 단계를 거친다.    <br />
Summary 단계는 앞서 GC를 수행한 영역에 대해서               <br />
별도로 살아있는 객체를 식별한다는 점에서 Mark-sweep-Compact 알고리즘의 sweep 단계와 다르게 조금 더 복잡하다.</p>

<p><strong>병렬 콜렉터와 동일하게 이 방식도 여러 CPU를 사용하는 서버에 적합하다.</strong></p>

<p><br /></p>

<h3 id="4-cms-gc">4. CMS GC</h3>
<p>로우 레이턴시 콜렉터(low-latency-collector)로도 알려져 있다. <br />
힙 메모리 영역이 클 때 적합하다. <br />
Young 영역에 대한 GC는 병렬 콜렉터와 동일하다. <br />
<br /></p>

<p>old 영역에 대한 GC는 다음과 같다.</p>

<ul>
  <li>
    <p>초기 Initial Mark 단계에서는 클래스 로더에서 가장 가까운 객체 중 살아있는 객체만 찾고 끝낸다.  <br />
이는 대기 시간이 매우 짧다.</p>
  </li>
  <li>
    <p>Concurrent Mark 단계에서는 방금 살아있다고 확인한 객체에서 참조하는 있는 객체들을 따라가면서 확인한다. <br />
특징은 다른 스레드가 실행중인 상태에서 동시에 실행된다는 것이다.</p>
  </li>
  <li>
    <p>Remark 단계에서는 새로 추가 되거나 참조가 끊긴 객체를 확인한다.</p>
  </li>
  <li>
    <p>Concurrent Sweep 단계에서는 쓰레기를 정리하는 단계이다.     <br />
특징은 Concurrent Mark 단계와 마찬가지로 다른 스레드가 실행하는 동시에 실행된다는 것이다.</p>
  </li>
</ul>

<p>CMS GC는 stop-the-world 시간이 짧다는 장점에 반해 다음과 같은 단점이 존재한다.</p>

<ul>
  <li>
    <p>다른 GC 방식보다 메모리와 CPU를 더 많이 사용한다.</p>
  </li>
  <li>
    <p>Compaction 단계가 기본적으로 제공되지 않는다.  <br />
조각난 메모리가 많아 Compaction 작업을 실행하면        <br />
다른 GC 방식의 stop-the-world 시간보다 stop-the-world 시간이 더 길기 때문에       <br />
Compaction 작업이 얼마나 자주, 오랫동안 수행되는지 확인해야 한다.</p>
  </li>
</ul>

<p><strong>이 방식은 2개 이상의 프로세서를 사용하는 서버에 적당하다. (예 - 웹 서버)</strong>                  <br />
<strong>Young 영역의 GC를 더 잘게 쪼개서 대기 시간을 줄일 수 있다.</strong>               <br />
<strong>모든 애플리케이션의 응답 속도가 매우 중요할 경우에 사용한다.</strong></p>

<p><br /></p>

<h3 id="5-g1-gc">5. G1 GC</h3>
<p>Garbage First 는 지금까지의 GC(Young, Old)와는 다른 영역으로 구성되어 있다.</p>

<p><strong>G1 GC의 Young GC</strong>  <br />
(1) 몇 개의 구역을 선정하여 Young 영역으로 지정한다. <br />
(2) 이 Linear 하지 않은 구역에 객체가 생성되면서 데이터가 쌓인다.  <br />
(3) Young 영역으로 할당된 구역에 데이터가 꽉차면 GC를 수행한다. <br />
(4) 살아남은 객체는 Sirvivor 구역으로 이동한다.</p>

<p>Old 영역 GC는 CMS GC 와 비슷하게 진행되며 여섯 단계로 나뉜다. <br />
여기서 STW라고 표시된 단계는 모두 Stop the world가 발생한다.</p>

<p><br /></p>

<p><strong>G1 GC의 Old GC</strong>   <br />
(1) 초기 표시 (STW) : Old 영역에 있는 객체에서 Survivor 영역의 객체를 참조하고 있는 객체들을 표시한다.</p>

<p>(2) 기본 구역 스캔 단계 : Old 영역 참조를 위해서 Survivor 영역을 훑는다.            <br />
참고로 이 작업은 Young GC가 발생하기 전에 수행 된다.</p>

<p>(3) 컨커런트 표시 단계 : 전체 힙 영역에 살아있는 객체를 찾는다.            <br />
만약 이때 Young GC가 발생하면 잠시 멈춘다.</p>

<p>(4) 재표시 단계 (STW) : 힙에 살아있는 객체들의 표시 작업을 완료한다.            <br />
이 떄 snapshot-at-the-beginning(SATB)라는 알고리즘을 사용하며, 이는 CMS GC에서 사용하는 방식보다 빠르다.</p>

<p>(5) 청소 단계 (STW) : 살아있는 객체와 비어 있는 구역을 식별하고, 필요 없는 객체들을 지운다.<br />
그리고 비어 있는 구역은 초기화한다.</p>

<p>(6) 복사 단계 (STW) : 살아있는 객체들을 비어 있는 구역으로 모은다.</p>

<p>G1은 CMS GC의 단점을 보완하기 위해 만들어졌으며 성능도 매우 빠르다.</p>

<p><br />  <br />
<br /></p>

<h1 id="gc가-어떻게-수행되고-있는지-보고-싶다면">GC가 어떻게 수행되고 있는지 보고 싶다면</h1>

<p>시스템을 분석하려면 관련된 툴을 사용해야 한다. <br />
여러 방법이 있는데 jstat 이라는 명령을 사용하여 실시간으로 보거나 verbosegc 옵션을 사용하여 로그를 남길 수도 있다.    <br />
<br /></p>

<h2 id="자바-인스턴스-확인을-위한-jps">자바 인스턴스 확인을 위한 jps</h2>
<p>jps는 해당 머신에서 운영 중인 JVM의 목록을 보여준다.     <br />
JDK의 bin 디렉터리에 있으며, 사용법이 매우 간단하다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jps [-q] [-mlvV] [-Joption] [&lt;hostid&gt;]     
</code></pre></div></div>

<p><br /></p>

<h2 id="gc-상황을-확인하는-jstat">GC 상황을 확인하는 jstat</h2>
<p>jstat는 GC가 수행되는 정보를 확인하기 위한 명령어이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]       
</code></pre></div></div>

<p>Garbage Collection 모니터링 방법 Naver D2 글 : https://d2.naver.com/helloworld/6043</p>

<p><br />   <br />
<br /></p>

<h1 id="gc-튜닝을-항상-할-필요는-없다">GC 튜닝을 항상 할 필요는 없다.</h1>

<p>결론부터 이야기하면 모든 Java 기반의 서비스에서 GC 튜닝을 진행할 필요는 없다.</p>

<p>GC 튜닝이 필요 없다는 이야기는 운영 중인 Java 기반 시스템의 옵션과 동작이 다음과 같다는 의미이다.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">-Xms</code> 옵션과 <code class="language-plaintext highlighter-rouge">–Xmx</code> 옵션으로 메모리크기를 지정했다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">-server</code> 옵션이 포함되어있다.</p>
  </li>
  <li>
    <p>시스템에 Timeout 로그와찍 같은 로그가 남지않는다.</p>
  </li>
</ul>

<p>(여기서 타임아웃이란 DB 작업과 관련된 타임아웃, 다른 서버와의 통신시 타임아웃)</p>

<p>즉, JVM 메모리 크기도 지정하지 않았고 Timeout 로그가 수도 없이 많이 출력되었다면 GC 튜닝을 하는 것이 좋다. <br />
그러나 한 가지 명심해야 할 것은 GC 튜닝은 가장 마지막에 하는 작업이라는 것이다.   <br />
<br /></p>

<p>GC 튜닝을 하는 이유가 무엇인지 근본적인 원인을 생각해 보자.          <br />
Java에서 생성된 객체는 가비지 컬렉터(Garbage Collector)가 처리해서 지운다.          <br />
생성된 객체가 많으면 많을수록 가비지 컬렉터가 가 처리해야 하는 대상도 많아지고, GC를 수행하는 횟수도 증가한다.          <br />
즉, 여러분이 운영하고 만드는 시스템이 GC를 적게 하도록 하려면 객체 생성을 줄이는 작업을 먼저 해야 한다.          <br />
<br /></p>

<p>운영하고 만드는 시스템이 GC를 적게 하도록 하려면 객체 생성을 줄이는 작업이 먼저 필요하다.</p>

<p>예를 들어, 이 책의 본문에 나오는 대부분의 내용을 지키면 된다.    <br />
String 대신 StringBuilder 나 StringBuffer 사용하거나,    <br />
로그를 최대한 적게 쌓도록 하는 등 임시 메모리를 적게 사용하도록 하는 작업은 중요하다.</p>

<p>만약 애플리케이션 메모리 사용도 튜닝을 많이 해서      <br />
어느 정도 만족할 만한 상황이 되었다면, 본격적으로 GC 튜닝을 시작하면 된다.</p>

<p>GC 튜닝의 목적을 두 가지로 나눠보자.</p>
<ul>
  <li>Old 영역으로 넘어가는 객체의 수 최소화하기</li>
  <li>Full GC의 실행 시간을 줄이기</li>
</ul>

<p><br /></p>

<h3 id="1-old-영역으로-넘어가는-객체의-수-최소화하기">(1) Old 영역으로 넘어가는 객체의 수 최소화하기</h3>

<p>Old 영역의 GC는 New 영역의 GC에 비하여 상대적으로 시간이 오래 소요되기 때문에 <br />
Old 영역으로 이동하는 객체의 수를 줄이면 Full GC가 발생하는 빈도를 많이 줄일 수 있다.</p>

<p>객체를 New 영역에만 남긴다는 것은 아니고,     <br />
New 영역의 크기를 잘 조절함으로써 큰 효과를 볼 수 있다는 것이다.</p>

<p><br /></p>

<h3 id="2-full-gc-시간-줄이기">(2) Full GC 시간 줄이기</h3>
<p>Full GC 수행 시간은 상대적으로 Young GC에 비하여 길다. <br />
그래서 Full GC 실행에 오랜 시간이 소요되면 연계된 여러 부분에서 타임아웃이 발생할 수 있다.</p>

<p>하지만 Old 영역의 크기를 줄여버리면 OutOfMemoryError가 발생하거나 Full GC 횟수가 늘어난다.  <br />
반대로 크기를 늘리면 Full GC 횟수는 줄어들지만 실행 시간이 늘어난다.   <br />
Old 영역의 크기를 적절하게 잘 설정해야 한다.</p>

<p><br /> <br />
<br /></p>

<h2 id="gc의-성능을-결정하는-옵션들">GC의 성능을 결정하는 옵션들</h2>

<p>이런 저런 옵션을 많이 설정한다고 시스템의 GC 수행 속도가 월등히 빨라지진 않는다.      <br />
오히려 더 느려질 확률이 높다. 두 대 이상의 서버에 GC 옵션을 다르게 적용해서 비교해 보고,       <br />
옵션을 추가한 서버의 성능이나 GC 시간이 개선된 때에만 옵션을 추가하는 것이 GC 튜닝의 기본 원칙다.       <br />
절대로 잊지 말자!</p>

<p><code class="language-plaintext highlighter-rouge">-Xms</code> 옵션(JVM 시작 시 힙 영역 크기)과 <code class="language-plaintext highlighter-rouge">-Xmx</code> 옵션(최대 힙 영역 크기)은 필수로 지정해야 하는 옵션이다.        <br />
그리고 <code class="language-plaintext highlighter-rouge">NewRatio</code> 옵션(New영역과 Old 영역의 비율)을 어떻게 설정하느냐에 따라서 GC 성능에 많은 차이가 발생한다.</p>

<p>GC 방식 중에서 특별히 신경쓸 필요가 없는 방식은 Serial GC다.     <br />
Serial GC는 클라이언트 장비에 최적화되어 있기 때문이다.</p>

<p><br />      <br />
<br /></p>

<h2 id="gc-튜닝의-절차">GC 튜닝의 절차</h2>

<p>(1) GC 상황 모니터링 <br />
GC 상황을 모니터링하며 현재 운영되는 시스템의 GC 상황을 확인해야 한다.</p>

<p>(2) 모니터링 결과 분석 후 GC 튜닝 여부 결정    <br />
분석한 결과를 확인했는데 GC 수행에 소요된 시간이 0.1~0.3초 밖에 안 된다면 굳이 GC 튜닝에 시간을 낭비할 필요는 없다.</p>

<p>하지만 GC 수행 시간이 1~3초, 심지어 10초가 넘는 상황이라면 GC 튜닝을 진행해야 한다.</p>

<p>그런데 만약 Java의 메모리를 10GB 정도로 할당해서 사용하고 있고 메모리의 크기를 줄일 수 없다면    <br />
방법은 없을 것 같다. <br />
GC 튜닝 전에 시스템의 메모리를 왜 높게 잡아야 하는지에 생각해 봐야 한다.</p>

<p>튜닝 여부 결정에 대한 자세한 내용은 책을 한번 더 확인…</p>

<p>(3) GC 방식 / 메모리 크기 지정 <br />
GC 튜닝을 진행하기로 결정했다면 GC 방식을 선정하고 메모리의 크기를 지정한다. <br />
이때 서버가 여러 대이면 서버에 GC 옵션을 서로 다르게 지정해서 GC 옵션에 따른 차이를 확인하는 것이 중요하다.</p>

<p>(4) 결과 분석    <br />
운이 좋으면 해당 시스템에 가장 적합한 GC 옵션을 찾을 수 있지만 그렇지 않다면 <br />
로그를 분석해 메모리가 어떻게 할당되는지 확인해야 한다. <br />
그 다음에 GC 방식 / 메모리 크기를 변경해 가면서 최적의 옵션을 찾아 나간다.</p>

<p>(5) 결과가 만족스러울 경우 전체 서버에 반영 및 종료</p>

<p><br />      <br />
<br /></p>

<h2 id="1-2-단계--gc-상황-모니터링-및-결과-분석하기">1, 2 단계 : GC 상황 모니터링 및 결과 분석하기</h2>

<p>다음의 조건에 모두 부합한다면 GC 튜닝이 필요 없다.</p>

<ul>
  <li>Minor GC의 처리 시간이 빠르다.</li>
  <li>Minor GC 주기가 빈번하지 않다.</li>
  <li>Full GC의 처리 시간이 빠르다.</li>
  <li>Full GC 주기가 빈번하지 않다.</li>
</ul>

<p>주의할 점은 GC 상황을 확인할 때 시간만 보면 안 된다는 점이다. <br />
GC 가 수행되는 횟수도 확인해야 한다.</p>

<p><br /></p>

<h2 id="31-단계--gc-방식-지정">3.1 단계 : GC 방식 지정</h2>

<p>Serial GC는 운영에서 사용하지 못해 제외되고, JDK 7이 아니면 G1 GC도 제외되어    <br />
Parallel GC, Parallel Compacting GC, CMS GC 중에서 하나를 선택해야 한다.</p>

<p>가장 좋은 방법은 세 가지 방식을 모두 적용해 보는 것이다. <br />
일반적으로 CMS GC가 다른 Parallel GC 보다 작업 속도가 빠르다.</p>

<p>하지만 항상 빠른 것은 아니다.  <br />
Concurrent mode failure 이 발생하면 다른 Parallel GC 보다 느려진다.<br />
<br /></p>

<p><strong>Concurrent mode failure 이란?</strong> <br />
Parallel GC와 CMS GC의 가장 큰 차이점은 압축(Compaction) 작업 여부이다.    <br />
압축 작업은 메모리 할당 공간 사이에 사용하지 않는 빈 공간이 없도록 옮겨서 메모리 단편화를 제거하는 작업이다.</p>

<p>CMS GC는 메모리에 빈 공간이 여기저기 생긴다. 그렇기 때문에 크기가 큰 객체가 들어갈 수 있는 공간이 없을 수도 있다.       <br />
예를들어, Old 영역에 남아 있는 크기가 300MB 인데도 10MB짜리 객체가 연속적로 들어갈 공간이 없을 수 있다.</p>

<p>그럴 때 Concurrent mode failure 라는 경고가 발생하면서 압축 작업을 수행한다. <br />
그런데, CMS GC를 사용할 때는 압축 시간이 다른 Parallel GC 보다 더 오래 소요된다. <br />
그래서 오히려 더 문제가 될 수 있다.</p>

<p><br />        <br />
<br /></p>

<h2 id="32-단계--메모리-크기">3.2 단계 : 메모리 크기</h2>

<p>메모리 크기와 GC 발생 횟수, GC 수행 시간의 관계는 다음과 같다.</p>

<p><strong>- 메모리 크기가 크면,</strong></p>
<ul>
  <li>GC 발생 횟수는 감소한다.</li>
  <li>GC 수행 시간은 길어진다.</li>
</ul>

<p><strong>- 메모리 크기가 작으면,</strong></p>
<ul>
  <li>GC 발생 시간는 짧아진다.</li>
  <li>GC 수행 횟수는 증가한다.</li>
</ul>

<p>메모리 크기를 크게 설정할 것인지, 작게 설정할 것인지에 대한 정답은 없다.</p>

<p><br />      <br />
<br /></p>

<h2 id="4단계--gc-튜닝-결과-분석">4단계 : GC 튜닝 결과 분석</h2>
<p>분석할 때에는 다음의 사항을 중심으로 살펴보는 것이 좋다.    <br />
GC 옵션을 결정하는 데 가장 큰 비중을 차지하는 것은 1번 항목인 Full GC 수행 시간이다.</p>

<ul>
  <li>Full GC 수행시간</li>
  <li>Minor GC 수행시간</li>
  <li>Full GC 수행간격</li>
  <li>Minor GC 수행간격</li>
  <li>전체 Full GC 수행시간</li>
  <li>전체 Minor GC 수행시간</li>
  <li>전체 GC 수행시간</li>
  <li>Full GC 수행횟수</li>
  <li>Minor GC 수행횟수</li>
</ul>

<p><br /></p>

<p>운이 좋아서 한 번에 가장 적합한 GC 옵션을 찾으면 좋지만, 그렇지 못한 경우가 대부분이다.    <br />
한 번에 끝내려다가 잘못하면 서비스에 OutOfMemoryError가 발생할 수 있으니 조심해서 GC 튜닝을 진행하는 것이 좋다.</p>

<p><br />      <br />
<br /></p>

<p><strong>같이 보면 좋은 GC 관련 블로그 글</strong></p>
<ul>
  <li><a href="https://hyerin6.github.io/2020-03-23/GC/">https://hyerin6.github.io/2020-03-23/GC/</a></li>
  <li><a href="https://hyerin6.github.io/2020-03-23/GC(2)/">https://hyerin6.github.io/2020-03-23/GC(2)/</a></li>
</ul>



  <br />

  <hr />

  <br />
  <script src="https://utteranc.es/client.js"
        repo="hyerin6/hyerin6.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
  </script>

</div>


    <!-- Documents about icons are here: http://fontawesome.io/icons/ -->
<div class="footer">
  <hr />

  <div class="footer-link">
    
    <a href="https://github.com/hyerin6"><i class="fa fa-github" aria-hidden="true"></i></a>
    
	
    
    <a href="mailto:hyerinn6@gmail.com"><i class="fa fa-envelope" aria-hidden="true"></i></a>
    
  </div>
  © 2022 Hyerin. All rights reserved.
</div>

<br />
<div class="footer">
    <a style="text-align: center;" href="https://hits.seeyoufarm.com">
      <img style="text-align: center;" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fhyerin6.github.io&count_bg=%23010101&title_bg=%23070707&icon=&icon_color=%23E7E7E7&title=visitors&edge_flat=false"/>
    </a>
</div>
  </div>
</body>
</html>
