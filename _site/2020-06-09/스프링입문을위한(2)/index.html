<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>자바 객체지향의 원리와 이해 (2)</title>

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css" type="text/css">

  <!-- Font -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css' rel='stylesheet' type='text/css'>
  <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for Hyerin Blog" href="/feed.xml" />
  <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>자바 객체지향의 원리와 이해 (2) | Hyerin Blog</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="자바 객체지향의 원리와 이해 (2)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="스프링 입문을 위한" />
<meta property="og:description" content="스프링 입문을 위한" />
<link rel="canonical" href="http://localhost:4000/2020-06-09/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9E%85%EB%AC%B8%EC%9D%84%EC%9C%84%ED%95%9C(2)/" />
<meta property="og:url" content="http://localhost:4000/2020-06-09/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9E%85%EB%AC%B8%EC%9D%84%EC%9C%84%ED%95%9C(2)/" />
<meta property="og:site_name" content="Hyerin Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-09T00:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="자바 객체지향의 원리와 이해 (2)" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2020-06-09/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9E%85%EB%AC%B8%EC%9D%84%EC%9C%84%ED%95%9C(2)/","headline":"자바 객체지향의 원리와 이해 (2)","dateModified":"2020-06-09T00:00:00+09:00","datePublished":"2020-06-09T00:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2020-06-09/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9E%85%EB%AC%B8%EC%9D%84%EC%9C%84%ED%95%9C(2)/"},"@type":"BlogPosting","description":"스프링 입문을 위한","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8RJ9ZZ1LSQ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8RJ9ZZ1LSQ', { 'anonymize_ip': false});
</script>


</head>

<body>
  <div class="content-container">
    <header>
  <div class="header-small">
    <a href="http://localhost:4000">Hyerin Blog</a>
  </div>
</header>
<div class="post">
  <div class="post-title">자바 객체지향의 원리와 이해 (2)</div>
  <br />
  <span class="post-date">
    <time>09 Jun 2020</time>
  </span>

  <div class="post-tag">
    <ul>
      
      <li>
        <a href="http://localhost:4000/tags#spring">
          <span>spring</span>
        </a>
      </li>
      
      
      <li>
        <a href="http://localhost:4000/tags#java">
          <span>java</span>
        </a>
      </li>
      
      
    </ul>
  </div>

  <p>자바가 객체지향을 확장하기 위해 사용하는 키워드를 살펴보자.</p>

<hr />

<h1 id="자바가-확장한-객체-지향">자바가 확장한 객체 지향</h1>

<h3 id="abstract-키워드---추상-메서드와-추상-클래스">abstract 키워드 - 추상 메서드와 추상 클래스</h3>

<p>동물 클래스가 있고 동물의 울음소리를 출력하는 추상 메서드인 울어보세요() 라는 메소드가 있다고 하자.   <br />
오리, 말, 고양이, 강아지 등의 동물들은 동물 클래스를 상속받아서 울음소리를 출력해야 한다.</p>

<p>우리에게는 두 문제가 있다.</p>
<ul>
  <li>동물 객체는 어떻게 울어야 하지? / 누가 실수로 동물 객체를 만들면 어떡하지?</li>
  <li>동물 참조 변수 배열로 모든 동물을 울게 하려면 하위 클래스에서 오버라이딩할 울어보세요() 메서드가 동물 클래스에 필요한데..</li>
</ul>

<p>이 두 문제가 추상 메서드와 추상 클래스로 한 번에 해결된다.  <br />
그뿐만 아니라 만약 동물을 상속한 하위 클래스가 울어보세요() 메서드를 오버라이딩하지 않으면 <br />
컴파일 시점에서 에러가 발생한다.</p>

<p>abstract 키워드에 대한 내용을 정리하면 다음과 같다.</p>

<ul>
  <li>
    <p>추상 클래스는 인스턴스, 즉 객체를 만들 수 없다.</p>
  </li>
  <li>
    <p>추상 메서드는 하위 클래스에게 메서드의 구현을 강제한다. <strong>오버라이딩 강제</strong></p>
  </li>
  <li>
    <p>추상 메서드를 하나라도 포함하고 있는 클래스는 반드시 추상 클래스여야 한다.</p>
  </li>
</ul>

<h3 id="생성자">생성자</h3>

<p>클래스의 인스턴스, 즉 객체를 만들 때마다 new 키워드를 사용한다.    <br />
우선 기억해야 할 자바의 특징이 있다.</p>

<ul>
  <li>개발자가 아무런 생성자도 만들지 않으면 자바는 인자가 없는 기본생성자를 자동으로 만들어준다.</li>
  <li>인자가 있는 생성자를 하나라도 만들면 자바는 기본 생성자를 만들어주지 않는다.</li>
</ul>

<p>생성자는 개발자가 필요한 만큼 오버로딩해서 만들 수 있다.        <br />
또한, 우리는 생성자라고 줄여서 부르지만 정확히는 <strong>객체 생성자 메서드</strong>임을 잊지 말자.</p>

<h3 id="클래스-생성-시의-실행-블록-static-블록">클래스 생성 시의 실행 블록, static 블록</h3>

<p>객체가 생성자가 있는 것이지 클래스 생성자는 없다.         <br />
그러나 클래스가 스태틱 영역에 배치될 때 실행되는 코드 블록이 있다. 바로 static 블록이다.</p>

<p>static 블록에서 사용할 수 있는 속성과 메서드는 당연하게 static 멤버 뿐이다.  <br />
예전에 작성한 게시글을 보면 이해할 수 있다.  <br />
T 메모리를 보면 객체 멤버에 접근할 방법이 없음을 알 수 있다.</p>

<p>객체 멤버는 클래스가 static 영역에 자리 잡은 후에 객체 생성자를 통해 힙에 생성된다.            <br />
클래스의 static 블록이 실행되고 있을 때는 해당 클래스의 객체는 하나도 존재하지 않기 때문에               <br />
static 블록에서는 객체 멤버에 접근할 수 없다.</p>

<p>당연한 이야기지만 어떤 클래스에 static 블록이 있으면,     <br />
그 블록은 객체가 생성될 때 실행되고 인스턴스 여러 개가 만들어져도 static 블록은 한 번만 실행된다.</p>

<p>클래스가 제일 처음 사용될 떄는 다음 중 하나이다.</p>
<ul>
  <li>클래스의 정적 속성을 사용할 때</li>
  <li>클래스의 정적 메서드를 사용할 때</li>
  <li>클래스의 인스턴스를 최초로 만들 때</li>
</ul>

<p>왜 프로그램이 실행될 때 바로 클래스들의 정보를 T 메모리의 static 영역에 로딩하지 않고 <br />
해당 클래스가 처음 사용될 때 로딩할까?   <br />
스태틱 영역도 메모리이기 때문이다. 메모리는 최대한 늦게 사용을 시작하고 최대한 빨리 반환하는 것이 정석이다.</p>

<h3 id="final-키워드">final 키워드</h3>

<p>final 키워드가 나타날 수 있는 곳은 딱 세 군데다. <br />
클래스, 변수, 메서드</p>

<ul>
  <li>
    <p>final과 클래스 <br />
상속을 허락하지 않겠다는 의미다.</p>
  </li>
  <li>
    <p>final과 변수 <br />
변경 불가능한 상수이다.</p>
  </li>
  <li>
    <p>final과 메서드<br />
재정의, 즉 오버라이딩을 금지한다.</p>
  </li>
</ul>

<h3 id="interface-키워드와-implements-키워드">interface 키워드와 implements 키워드</h3>

<p>인터페이스는 public 추상 메서드와 public 정적 상수만 가질 수 있다.</p>

<p>그래서 인터페이스는 메서드에 public과 abstract,     <br />
속성에 public과 static, final을 붙이지 않아도 자동으로 자바가 알아서 붙여준다.</p>

<h3 id="this-키워드">this 키워드</h3>

<p>this는 객체가 자기 자신을 지칭할 때 쓰는 키워드다.     <br />
아래 내용을 기억해두자.</p>

<ul>
  <li>
    <p>지역 변수와 속성의 이름이 같은 경우 지역 변수가 우선이다.</p>
  </li>
  <li>
    <p>객체 변수와 이름이 같은 지역 변수가 있는 경우 객체 변수를 사용하려면 this를 접두사로 사용한다.</p>
  </li>
  <li>
    <p>정적 변수와 이름이 같은 지역 변수가 있는 경우 정적 변수를 사용하려면 클래스명을 접두사로 사용한다.</p>
  </li>
</ul>

<h3 id="super-키워드">super 키워드</h3>

<p>바로 위 상위 클래스의 인스턴스를 지칭하는 키워드다. <br />
super 키워드로 바로 위의 상위 클래스 인스턴스에만 접근할 수 있다. <br />
super.super 과 같은 형태는 안된다.</p>

<h3 id="클래스명객체메서드명">클래스명.객체메서드명()</h3>

<p>객체 메서드를 호출할 때 스택 정보를 보면   <br />
<code class="language-plaintext highlighter-rouge">객체명.객체메서드명()</code>이 아닌 <code class="language-plaintext highlighter-rouge">클래스명.객체메서드명()</code>임을 확인할 수 있다.</p>

<p>만약 객체가 <code class="language-plaintext highlighter-rouge">a[100]</code> 처럼 요소가 100개인 배열이라면 힙 영역에 생기는 객체는 100개가 되고 <br />
메서드도 각 객체에 따라 100개가 만들어져야 한다. <br />
하지만 메서드가 객체에 따라 달라지는 것은 아니다. 객테 멤버 메서드에서 사용하는 객체 멤버 속성의 값만 다를 뿐이다. <br />
메서드를 힙 영역에 100개나 만드는 것은 심각한 메모리 낭비라고 할 수 있다.</p>

<p>그래서 JVM은 객체 멤버 메서드를 스태틱 영역에 단 하나만 보유한다. <br />
그리고 눈에 보이지는 않지만 메서드를 호출할 때 객체 자신을 나타내는 this 객체 참조 변수를 넘긴다.</p>



  <br />
  <script src="https://utteranc.es/client.js"
        repo="hyerin6/hyerin6.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
  </script>

</div>


    <!-- Documents about icons are here: http://fontawesome.io/icons/ -->
<div class="footer">
  <hr />
  <div class="footer-link">
	
    
    <a href="https://github.com/hyerin6"><i class="fa fa-github" aria-hidden="true"></i></a>
    
	
    
    <a href="mailto:hyerinn6@gmail.com"><i class="fa fa-envelope" aria-hidden="true"></i></a>
    

  </div>
  © 2022 Hyerin. All rights reserved.
</div>

  </div>
</body>
</html>
