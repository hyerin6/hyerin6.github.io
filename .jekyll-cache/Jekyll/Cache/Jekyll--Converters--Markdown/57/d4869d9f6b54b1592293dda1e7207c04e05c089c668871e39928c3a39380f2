I"<h3 id="1-springboot-jpa--hibernate-naming-strategy-네이밍-전략">1. Springboot jpa &amp; Hibernate Naming Strategy (네이밍 전략)</h3>

<p>local에서 <code class="language-plaintext highlighter-rouge">jpa.hibernate.ddl-auto</code>를 <code class="language-plaintext highlighter-rouge">create</code>로 설정해놨는데    <br />
자동 생성된 테이블의 컬럼명을 보니 snake_case로 생성되어 있었다..</p>

<ul>
  <li>application.yml
    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spring</span><span class="pi">:</span>
<span class="na">jpa</span><span class="pi">:</span>
  <span class="na">hibernate</span><span class="pi">:</span>
    <span class="na">naming</span><span class="pi">:</span>
      <span class="na">physical-strategy</span><span class="pi">:</span> <span class="s">org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl</span>
</code></pre></div>    </div>
    <p>위 설정을 해주면 Entity 클래스의 변수명과 동일하게 생성된다.</p>
  </li>
</ul>

<h3 id="2-spring-security">2. Spring Security</h3>

<p>회원가입 시 이메일 인증으로 사용자 인증을 하고 인증 완료 여부를 
Role로 구분하려고 spring 표준 권한을 찾아봤다.</p>

<p><strong>스프링에서 제공하는 기본 권한(Authority)</strong></p>
<ul>
  <li>ROLE_ANONYMOUS : 모든 사용자</li>
  <li>IS_AUTHENTICATED_ANONYMOUSLY : 익명 사용자</li>
  <li>IS_AUTHENTICATED_FULLY : 인증된 사용자</li>
  <li>IS_AUTHENTICATED_REMEMBERED : REMEMBERED 사용자</li>
  <li>ROLE_RESTRICTED : 제한된 사용자</li>
  <li>ROLE_USER : 일반 사용자</li>
  <li>ROLE_ADMIN : 관리자</li>
</ul>

<p>이번 프로젝트에서 미인증 사용자는 <code class="language-plaintext highlighter-rouge">ROLE_RESTRICTED</code>로   <br />
인증 완료 사용자는 <code class="language-plaintext highlighter-rouge">IS_AUTHENTICATED_FULLY</code>로 설정하기로 했다.</p>

:ET