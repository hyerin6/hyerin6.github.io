I"U<p><br /></p>

<h2 id="69-예외는-진짜-예외-상황에만-사용하자">69. 예외는 진짜 예외 상황에만 사용하자.</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">range</span><span class="o">[</span><span class="n">i</span><span class="o">++].</span><span class="na">climb</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">ArrayIndexOutOfBoundsException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 코드는 무슨 일을 하는 걸까?<br />
전혀 직관적이지 않다. 배열의 원소를 순회하는데 무한루프를 돌다가 배열의 끝에 도달해 <br />
ArrayIndexOutOfBoundsException이 발생하면 끝을 내는 코드이다.</p>

<p>다음과 같이 변경하면 개발자는 바로 이해했을 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="o">(</span><span class="nc">Mountain</span> <span class="n">m</span> <span class="o">:</span> <span class="n">range</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 표준 관용구 </span>
    <span class="n">m</span><span class="o">.</span><span class="na">climb</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Q. 왜 예외를 써서 루프를 종료했을까?  <br />
A. 잘못된 추론을 근거로 성능을 높여보려 한 것이다.</p>

<p>JVM은 배열에 접근할 때마다 경계를 넘지 않는지 검사하는데 일반적인 반복문도 배열 경계에 도달하면 종료한다.  <br />
따라서 이 검사를 반복문에도 명시하면 같은 일이 중복되므로 하나를 생략한 것이다.   <br />
그러나 잘못된 추론이다.<br />
실제로는 예외를 사용한 쪽이 표준 관용구보다 훨씬 느리다.</p>

<p><br /></p>

<h4 id="잘못된-추론">잘못된 추론</h4>
<ol>
  <li>예외는 예외 상황에 쓸 용도로 설계되었으므로 JVM 구현자 입장에서는 명확한 검사만큼 빠르게 만들어야 할 동기가 약하다.   <br />
(최적화에 별로 신경쓰지 않았을 가능성이 크다.)</li>
  <li>코드를 try-catch 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한된다.</li>
  <li>배열을 순회하는 표준 관용구는 앞서 걱정한 중복 검사를 수행하지 않는다. <br />
JVM이 알아서 최적화를 없애준다.</li>
</ol>

<p><br /></p>

<h4 id="예외를-사용한-반복문의-문제점">예외를 사용한 반복문의 문제점</h4>
<ul>
  <li>코드를 헷갈리게 하고 성능을 떨어뜨린다.</li>
  <li>제대로 동작하지 않을 수도 있다.
    <ul>
      <li>반복문 안에 버그가 숨어있으면 흐름 제어에 쓰인 예외가 이 버그를 숨겨 디버깅을 훨씬 어렵게 할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h4 id="예외-원칙">예외 원칙</h4>
<ul>
  <li>예외는 오직 예외 상황에서만 써야 한다. 절대로 일상적인 제어 흐름용으로 쓰여선 안 된다.</li>
  <li>잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.</li>
  <li>특정 상태에서만 호출할 수 있는 ‘상태 의존적’ 메서드를 제공하는 클래스는 ‘상태 검사’ 메서드도 함께 제공해야 한다.</li>
</ul>

<p><br /></p>

<h4 id="상태-검사-메서드-대신-사용-가능한-선택지">상태 검사 메서드 대신 사용 가능한 선택지</h4>
<ol>
  <li>외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 옵셔널이나 특정 값을 사용한다.
    <ul>
      <li>상태 검사 메소드와 상태 의존적 메소드 호출 사이에 객체의 상태가 변할 수 있기 때문이다.</li>
    </ul>
  </li>
  <li>성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메소드의 작업 일부를 중복 수행한다면 옵셔널이나 특정 값을 사용한다.</li>
  <li>그 외 다른 경우에는 상태 검사 메소드를 사용하는 것이 낫다.</li>
</ol>

<p><br />
<br /></p>

<h2 id="70-복구할-수-있는-상황에는-검사-예외를-프로그래밍-오류에는-런타임-예외를-사용하자">70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하자.</h2>
<p>자바는 문제 상황을 알리는 타입(throwable)으로 검사 예외, 런타임 예외, 에러 이렇게 세 가지를 제공한다.</p>

<p><img width="700" src="https://www.nextree.co.kr/content/images/2021/01/Exception-Class.png" /></p>

<p><br /></p>

<h4 id="오류error">오류(Error)</h4>
<ul>
  <li>시스템에 비정상적인 상황이 생겼을 때 발생</li>
  <li>시스템 레벨에서 발생하기 때문에 심각한 수준의 문제상황</li>
</ul>

<p><br /></p>

<h4 id="예외exception">예외(Exception)</h4>
<ul>
  <li>개발자가 구현한 로직에서 발생</li>
  <li>예외는 발생할 상황을 미리 예측하여 처리할 수 있음</li>
  <li>예외는 개발자가 처리를 할 수 있기 때문에 예외를 구분하고, 그에 따라 처리 방법을 명확히 알고 사용하는 것이 중요함</li>
</ul>

<p><br /></p>

<h4 id="검사-예외checked-exception">검사 예외(Checked Exception)</h4>
<ul>
  <li>컴파일 단계에서 명확하게 Exception 체크가 가능한 것</li>
  <li>반드시 예외 처리를 해주어야 함</li>
  <li>컴파일 단계에서 확인</li>
  <li>ex) ClassNotFoundException, IOException</li>
</ul>

<p><br /></p>

<h4 id="런타임-예외runtime-exception">런타임 예외(Runtime Exception)</h4>
<ul>
  <li>실행과정 중 발견됨</li>
  <li>명시적인 처리를 강제하지 않음</li>
  <li>ex) NullPointerException, IndexOutOfBoundException</li>
</ul>

<p><br /></p>

<h4 id="검사-예외">검사 예외</h4>
<ul>
  <li>호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라.</li>
  <li>이것이 검사와 비검사 예외를 구분하는 기본 규칙이다.</li>
  <li>검사 예외를 던지면 호출자가 그 예외를 catch로 잡아 처리하거나 더 바깥으로 전파하도록 강제하게 된다.</li>
  <li>따라서 메서드 선언에 포함된 검사 예외 각각은 그 메서드를 호출했을 때 발생할 수 있는 유력한 결과임을 API 사용자에게 알려주는 것이다.</li>
</ul>

<p><br /></p>

<h4 id="비검사---런타임-예외-에러">비검사 - 런타임 예외, 에러</h4>
<ul>
  <li>
    <p>이 둘은 프로그램에서 잡을 필요가 없거나 혹은 통상적으로 잡지 말아야 한다.<br />
이는 복구가 불가능하거나 더 실행해봐야 득보다 실이 많다는 뜻이기 때문이다.</p>
  </li>
  <li>
    <p>프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자.  <br />
런타임 예외의 대부분은 전제조건을 만족하지 못했을 때 발생한다.<br />
복구 가능하다고 믿는다면 검사 예외를, 그렇지 않다면 런타임 예외를 사용하자.</p>
  </li>
  <li>
    <p>확신하기 어렵다면 비검사 예외를 선택하는 편이 나을 것이다.</p>
  </li>
</ul>

<p><br /></p>

<h4 id="에러">에러</h4>
<ul>
  <li>에러는 보통 JVM이 자원 부족, 불변식 깨짐 등의 상황일 때 사용한다.</li>
  <li>Error 클래스를 상속해 하위 클래스를 만드는 일은 자제해야 한다.</li>
  <li>Error는 상속하지 말아야 할 뿐 아니라, throw 문으로 직접 던지는 일도 없어야 한다.</li>
</ul>

<p><br /></p>

<h4 id="핵심-정리">핵심 정리</h4>
<ul>
  <li>복구할 수 있는 상황이면 검사 예외를, 프로그래밍 오류라면 비검사 예외를 던지자.</li>
  <li>확실하지 않다면 비검사 예외를 던지자.</li>
  <li>검사 예외도 아니고, 런타임 예외도 아닌 throwable은 정의하지도 말자.</li>
  <li>검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하자.</li>
</ul>

<p><br />
<br /></p>

<h2 id="71-필요-없는-검사-예외-사용은-피하자">71. 필요 없는 검사 예외 사용은 피하자.</h2>
<p>검사 예외는 제대로 활용하면 api와 프로그램의 질을 높일 수 있다. <br />
검사 예외는 발생한 문제를 프로그래머가 처리하여 안정성을 높이게끔 해준다. <br />
물론 검사 예외를 사용하면, 오히려 쓰기 어려운 api가 된다. <br />
어떤 메서드가 검사 예외를 던질 수 있다고 선언됐다면, 이를 호출하는 코드쪽에서 반드시 그 예외를 처리해 주어야 한다. <br />
이를 붙잡아(catch) 처리하거나 혹은 더 바깥으로 던져 문제를 전파해야된다.<br />
<br /></p>

<h4 id="검사-예외-회피하기">검사 예외 회피하기</h4>
<p>검사 예외를 회피하는 가장 쉬운 방법은 적절한 결과 타입을 담은 옵셔널을 반환하는 것이다.   <br />
검사 예외를 던지는 대신에 단순히 빈 옵셔널을 반환하면 된다. <br />
이 방식의 단점은 예외가 발생한 이유를 알려주기 어렵다는 것이다.</p>

<p>혹은 두개의 메서드로 쪼개는 방법이 있다. <br />
<br /></p>

<h4 id="검사-예외를-두개의-메서드로-쪼개기">검사 예외를 두개의 메서드로 쪼개기</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 리펙토링 전 메서드</span>
<span class="k">try</span> <span class="o">{</span>
	<span class="n">obj</span><span class="o">.</span><span class="na">action</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">TheCheckedExcpetion</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">// ...</span>
<span class="o">}</span>


<span class="c1">// 리펙토링 후 메서드</span>
<span class="k">if</span><span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">actionPermitted</span><span class="o">(</span><span class="n">args</span><span class="o">))</span> <span class="o">{</span>
	<span class="n">obj</span><span class="o">.</span><span class="na">action</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
	<span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이렇게 예외 케이스인지 검사하는 메서드를 추가하고 예외 케이스인 경우에는 <br />
런타임 익셉션(Unchecked exception)으로 해결하는 방법도 있다.  <br />
이 방식을 모든 코드에 적용할 수는 없지만, 훨씬 유연한 구조임은 사실이다.</p>

<p><br />
<br /></p>

<h2 id="72-표준-예외를-사용하자">72. 표준 예외를 사용하자.</h2>
<p>표준 예외를 재사용하면 장점이 많다.   <br />
내가 작성한 API가 다른 사람이 익히고 사용하기 쉬워진다는 것이다. <br />
예외 클래스 수가 적을수록 메모리 사용량도 줄고 클래스를 적재하는 시간도 적게 걸린다.</p>

<h4 id="illegalargumentexception">IllegalArgumentException</h4>
<p>가장 많이 사용되는 예외이다. 호출자가 인수로 부적절한 값을 넘길 때 던지는 예외이다.<br />
사용 예시) 반복 횟수를 지정하는 매개변수에 음수를 건넬 때</p>

<h4 id="illegalstateexception">IllegalStateException</h4>
<p>대상 객체의 상태가 호출된 메서드를 수행하기에 적합하지 않을 때 주로 사용된다.<br />
사용 예시) 제대로 초기화되지 않은 객체를 사용하려고 할 때</p>

<h4 id="concurrentmodificationexception">ConcurrentModificationException</h4>
<p>단일 스레드에서 사용하려고 설계한 객체를 여러 스레드가 동시에 수정할 때 던진다.</p>

<h4 id="unsupportedoperationexception">UnsupportedOperationException</h4>
<p>클라이언트가 요청한 동작을 대상 객체가 지원하지 않을 때 사용된다.<br />
사용 예시) 원소를 넣을수만 있는 List의 구현체에 누군가 remove 메서드를 호출할 때</p>

<h4 id="그-외">그 외</h4>
<p>Exception, RuntimeException, Throwable, Error는 직접 사용하지 말자.<br />
이 클래스들은 추상 클래스라고 생각하면 된다.   <br />
이 예외들은 다른 예외들의 상위 클래스이므로 안정적으로 테스트 하기 어렵다.</p>

<p><br />
<br /></p>

<h2 id="73-추상화-수준에-맞는-예외를-던지자">73. 추상화 수준에 맞는 예외를 던지자.</h2>
<p>수행하려는 일과 관련 없어 보이는 예외가 튀어나오면 당황스러울 것이다. <br />
이는 윗 레벨 api를 오염 시킬 수 있다.<br />
<br /></p>

<h4 id="예외-번역exception-translation">예외 번역(Exception translation)</h4>
<p>앞서 서술한 문제를 피하기 위해서는 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꾸어 주어야 한다.   <br />
이를 예외 번역이라고 한다.</p>

<p><br /></p>

<h4 id="예시">예시</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
	<span class="c1">// 저수준 추상화를 이용</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">LowerLevelException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">throw</span> <span class="k">new</span> <span class="nf">HigherLevelException</span><span class="o">();</span>
<span class="o">}</span> 
</code></pre></div></div>

<p><br /></p>

<h4 id="abstractsequentiallist에서-수행하는-예시">AbstractSequentialList에서 수행하는 예시</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="no">E</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
	<span class="nc">ListIterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">listIterator</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
	<span class="k">try</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">i</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
	<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">NoSuchElementException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">throw</span> <span class="k">new</span> <span class="nf">IndexOutOfBoundsException</span><span class="o">(</span><span class="s">"인덱스: "</span> <span class="o">+</span> <span class="n">index</span><span class="o">);</span>
	<span class="o">}</span>

<span class="o">}</span> 
</code></pre></div></div>

<p><br /></p>

<h4 id="예외를-번역하기">예외를 번역하기</h4>
<p>저수준 예외가 디버깅에 도움이 될 때가 있다. <br />
그렇다면, 예외 연쇄(exception chaining)을 사용하는 것이 좋다.  <br />
예외 연쇄란 문제의 근본 원인(cause)인 저수준 예외를 고수준 예외에 실어 보내는 방식이다.</p>

<p><br /></p>

<h4 id="예시-1">예시</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
	<span class="c1">// 저수준 추상화를 사용</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">LowerLevelException</span> <span class="n">cause</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">// 저수준 예외를 고수준 예외에 실어 보낸다.</span>
	<span class="k">throw</span> <span class="k">new</span> <span class="nf">HigherLevelException</span><span class="o">(</span><span class="n">cause</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>대부분의 표준 예외는 예외 연쇄용 생성자를 갖추고 있다.</p>

<p><br /></p>

<h4 id="적절하게-사용하기">적절하게 사용하기</h4>
<p>무턱대고 예외를 전파하기 보다는 가능하다면 저수준 메서드가 반드시 성공하도록 하여 <br />
아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선이다.</p>

<p><br /></p>

<h4 id="차선책">차선책</h4>
<p>아래 계층에서의 예외를 피할 수 없다면, 상위 계층에서 그 예외를 조용히 처리하여 api 호출자에까지 전파하지 않는 방법이 있다.</p>

<p><br />
<br /></p>

<h2 id="75-예외의-상세-메시지에-실패-관련-정보를-담자">75. 예외의 상세 메시지에 실패 관련 정보를 담자.</h2>
<p>예외를 잡지 못해 프로그램이 실패하면 자바 시스템은 스택 추적 정보를 자동으로 출력한다. <br />
스택 추적은 예외 객체의 toString 메서드를 호출해 얻는 문자열이다.</p>

<p>예외의 toString 메서드에 실패 원인에 관한 정보를 가능한 한 많이 담아 반환하는 일은 아주 중요하다.</p>

<p><br /></p>

<h4 id="실패의-순간-포착하기">실패의 순간 포착하기</h4>
<p>실패의 순간을 포착하려면 발생한 예외에 관여된 모든 매개변수와 필드의 값을 메세지에 담아야 한다. <br />
예컨대 IndexOutOfBoundsException의 상세 메세지는 범위의 최소, 최대    <br />
그리고 그 범위를 벗어난 인덱스 값을 모두 담아야 한다. <br />
그래야 이 메세지를 보고 무엇을 고쳐야 할지를 분석하는 데 도움이 된다.</p>

<p><br /></p>

<h4 id="실패-메세지">실패 메세지</h4>
<p>예외의 상세 메세지와 최종 사용자에게 보여줄 오류 메세지를 혼동해서는 안된다.     <br />
최종 사용자는 친절한 안내메세지를 받아야 하는 한편, 예외 메세지는 가독성보다는 담긴 내용이 훨신 중요하다.     <br />
이를 적절히 구분하여 오류 메세지를 만들자.</p>

<p><br />
<br /></p>

<h2 id="76-가능한-한-실패-원자적으로-만들자">76. 가능한 한 실패 원자적으로 만들자.</h2>
<p>검사 예외를 던진 경우라면 호출자가 오류 상태를 복구할 수 있을 테니 특히 더 유용하다. <br />
호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야 한다. <br />
이러한 특성을 실패 원자적이라고 한다. <br />
<br /></p>

<h4 id="메서드를-실패-원자적으로-만들기">메서드를 실패 원자적으로 만들기</h4>
<p>가장 간단한 방법은 불변 객체로 설계하는 것이다. 불변 객체는 실패 원자적이다.   <br />
메서드가 실패하면 새로운 객체가 만들어지지 않을 수는 있으나, 기존 객체가 불안정한 상태에 빠지는 일은 결코 없다.</p>

<p>가변 객체는 어떻게 하면 좋을까? 가장 흔한 방법은 작업 수행에 앞서 매개변수의 유효성을 검사하는 것이다. <br />
객체의 내부 상태를 변경하기 전에 잠재적 예외의 가능성을 걸러낼 수 있는 방법이다.<br />
<br /></p>

<ul>
  <li>예시</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">Object</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
		<span class="k">throw</span> <span class="k">new</span> <span class="nf">EmptyStackException</span><span class="o">();</span>
	<span class="nc">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">elements</span><span class="o">[--</span><span class="n">size</span><span class="o">];</span>
	<span class="n">elements</span><span class="o">[</span><span class="n">size</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 다 쓴 참조 해제</span>
	<span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 메서드는 처음의 if문에서 size의 값을 확인하여 0이면 바로 예외를 던진다.</p>

<ul>
  <li>
    <p>객체의 임시 복사본에서 작업을 수행한 다음, 작업이 성공적으로 완료되면 원래 객체와 교체하는 것이다.</p>
  </li>
  <li>
    <p>실패를 가로채는 복구코드를 작성하여 작업 전 상태로 되돌리는 방법이 있다. <br />
주로 내구성을 보장해야 하는 자료구조에 쓰인다.</p>
  </li>
</ul>

:ET