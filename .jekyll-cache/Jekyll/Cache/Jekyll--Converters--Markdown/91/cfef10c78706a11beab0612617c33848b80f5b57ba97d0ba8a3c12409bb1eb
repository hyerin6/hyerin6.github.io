I"!<p>JSP와 Servlet의 기본적인 동작원리를 알아보자.  <br />
일반적으로 JSP와 같은 웹 화면단을 처리하는 부분에서 소요되는 시간은 많지 않다.  <br />
JSP의 경우 가장 처음에 호출되는 경우에만 시간이 소요되는 이후에는 컴파일된 서블릿 클래스가 수행되기 때문이다.  <br />
<br /></p>

<h2 id="jsp-라이프-사이클">JSP 라이프 사이클</h2>
<p>(1) JSP URL 호출       <br />
(2) 페이지 번역          <br />
(3) JSP 페이지 컴파일         <br />
(4) 클래스 로드        <br />
(5) 인스턴스 생성        <br />
(6) jspInit 메서드 호출        <br />
(7) _jspService 메서드 호출        <br />
(8) jspDestory 메서드 호출        <br />
<br /></p>

<p>해당 JSP 페이지가 이미 컴파일되어 있고 클래스 로드되어 있고           <br />
JSP 파일이 변경되지 않았다면 가장 많은 시간이 소요되는 (2)~(4) 프로세스는 생략된다.</p>

<p><br /></p>

<h2 id="서블릿-라이프-사이클">서블릿 라이프 사이클</h2>
<p>WAS의 JVM이 시작한 후에는,</p>

<p>Servlet 객체가 자동으로 생성되거나 초기화 되거나 <br />
사용자가 해당 Servlet을 처음으로 호출했을 때 생성되고 초기화 된다. <br />
<br /></p>

<p><img src="https://user-images.githubusercontent.com/33855307/125027854-f0e85500-e0c1-11eb-806a-b577d0bb09e0.jpeg" alt="KakaoTalk_Photo_2021-07-09-14-25-47" /></p>

<p><br /></p>

<p>그 다음 계속 <code class="language-plaintext highlighter-rouge">사용 가능</code> 상태로 대기한다.    <br />
중간에 예외가 발생하면 <code class="language-plaintext highlighter-rouge">사용 불가능</code> 상태로 빠졌다가 다시 <code class="language-plaintext highlighter-rouge">사용 가능</code> 상태로 변환되기도 한다.    <br />
해당 서블릿이 더 이상 필요 없을 때는 <code class="language-plaintext highlighter-rouge">파기</code> 상태로 넘어간 후 JVM에서 <code class="language-plaintext highlighter-rouge">제거</code> 된다.</p>

<p>서블릿은 JVM에 여러 객체로 생성되지 않는다.  <br />
다시 말해 WAS가 시작하고, <code class="language-plaintext highlighter-rouge">사용 가능</code> 상태가 된 이상 대부분의 서블릿은 JVM에 살아있고,    <br />
여러 스레드에서 해당 서블릿의 <code class="language-plaintext highlighter-rouge">service()</code> 메서드를 호출하여 공유한다.</p>

<p>만약 서블릿 클래스이 메서드 내에 선언한 지역 변수가 아닌 멤버 변수 (인스턴스 변수)를 선언하여  <br />
<code class="language-plaintext highlighter-rouge">service()</code> 메서드에서 사용하면 어떤 일이 벌어질까?</p>

<p>static을 사용하는 것과 거의 동일한 결과를 나타낸다.  <br />
<code class="language-plaintext highlighter-rouge">service()</code> 메서드를 구현할 때는 멤버 변수나 static한 클래스 변수를 선언하여 <br />
지속적으로 변경하는 작업은 피해야한다.</p>

<p><br /></p>

<h4 id="--스프링-프레임워크-간단-정리">- 스프링 프레임워크 간단 정리</h4>

<p>스프링 프레임워크는 데스크톱과 웹 어플리케이션, 작고 간단한 애플리케이션부터          <br />
여러 서버와 연동하여 동작해야 하는 엔터프라이즈 애플리케이션도 범용적인 애플리케이션 프레임워크이다.</p>

<p>Spring의 가장 큰 특징은 복잡한 애플리케이션도 POJO(Plain Old Java Object)로 개발할 수 있다는 점이다. <br />
서블릿을 개발하려면 반드시 HttpServlet이라는 클래스를 상속해야 한다. <br />
하지만 스프링을 사용하면 HttpServlet을 확장하지 않아도 웹 요청을 처리할 수 있는 클래스를 만들 수 있다.</p>

<p><br /></p>

<h2 id="스프링의-핵심-기술">스프링의 핵심 기술</h2>
<p>Dependency Injection, <br />
Aspect Oriented Programming, <br />
Portable Service Abstraction 으로 함축할 수 있다. <br />
<br /></p>

<p>(1) Dependency Injection   <br />
‘의존성 주입’ 이라고 한다.  <br />
객체간의 관계를 관리하는 기술로 생각하면 된다.   <br />
어떤 객체가 필요로 하는 객체를 자기 자신이 직접 생성하여 사용하는 것이 아니라  <br />
외부에 있는 다른 무언가로부터 필요로 하는 객체를 주입 받는 기술이다.</p>

<p>(2) AOP (Aspect Oriented Programming)  <br />
‘관점 지향 프로그래밍’ 이라고 부른다. <br />
대부분은 비슷한 코드가 중복되고 코드를 읽는 데 방해가 된다. <br />
이런 코드를 실제 비즈니스 로직과 분리할 수 있도록 도와주는 것이 바로 AOP이다.</p>

<p>자바에서 가장 유명한 AOP 프레임워크로는 AspectJ가 있다.</p>

<p>(3) PSA (Portable Service Abstraction)  <br />
스프링은 비슷한 기술을 모두 아우를 수 있는 추상화 계층을 제공하여, 사용하는 기술이 바뀌더라도 <br />
비즈니스 로직의 변화가 없도록 도와준다.</p>

<p><br /></p>

<h2 id="스프링-프레임워크를-사용하면서-발생할-수-있는-문제점들">스프링 프레임워크를 사용하면서 발생할 수 있는 문제점들</h2>

<p>스프링 프레임워크를 사용할 때 성능 문제가 가장 많이 발생하는 부분은 <strong>프록시(proxy)</strong> 와 관련이 있다. <br />
스프링 프록시는 기본적으로 실행 시에 생성된다.   <br />
따라서 요청량이 많은 운영 상황으로 넘어가면 문제가 나타날 수 있다.</p>

<p>스프링이 프록시를 사용하게 하는 주요 기능은 <strong>트랜잭션</strong>이다.  <br />
<code class="language-plaintext highlighter-rouge">@Transaction</code> 어노테이션을 사용하면 해당 어노테이션을 사용한 클래스의 인스턴스를 처음 만들 때 프록시 객체를 만든다. <br />
개발자가 직접 스프링 <strong>AOP</strong>를 사용해서 별도의 기능을 추가하는 경우에도 프록시를 사용하는데, <br />
이 부분에서 문제가 많이 발생한다.</p>

<p>따라서, 간단한 부하 툴을 사용해서라도 성능적인 면을 테스트해야만 한다.</p>

<p>추가로, 스프링이 <strong>내부 매커니즘에서 사용하는 캐시</strong>도 조심해야 한다. <br />
예를들어 스프링 MVC에서 작성하는 메서드의 리턴 타입으로 다음과 같은 문자열을 사용할 수 있다. <br />
이 때 매번 동일한 문자열에 대한 뷰 객체를 새로 찾기 보다는 이미 찾아본 뷰 객체를 캐싱해두면    <br />
다음에도 동일한 문자열이 반환됐을 때 훨씬 빠르게 뷰 객체를 찾을 수 있다.</p>

<p>스프링이 제공하는 <code class="language-plaintext highlighter-rouge">ViewResolver</code> 중에 자주 사용되는 <code class="language-plaintext highlighter-rouge">InternalResourceViewResolver</code>에는 그러한 캐싱 기능이 내장되어 있다. <br />
(<code class="language-plaintext highlighter-rouge">ViewResolver</code>는 뷰 이름과 지역화를 위한 Locale을 파라미터로 전달받으며,      <br />
매핑되는 View 객체를 리턴한다. 만약, 매핑되는 View 객체가 존재하지 않으면 null을 리턴한다.)</p>

<p>만약 매번 다른 문자열이 생성될 가능성이 높고, 상당히 많은 수의 키 값으로 캐싱 값이 생성될 여지가 있는 상황에서는 <br />
문자열을 반환하는 게 메모리에 치명적일 수 있다.</p>

<p>이런 상황에서는 뷰 이름을 문자열로 변환하기보다는 뷰 객체 자체를 반환하는 방법이 메모리 릭을 방지하는 데 도움이 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/members/{id}"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">View</span> <span class="nf">hello</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">RedirectView</span><span class="o">(</span><span class="s">"/members/"</span> <span class="o">+</span> <span class="n">id</span><span class="o">);</span>
<span class="o">}</span>    
</code></pre></div></div>

<p><br /></p>

:ET