I"<p><br /></p>

<p><strong>이전 게시글</strong></p>

<ul>
  <li>Spring 정의: <a href="https://hyerin6.github.io/2021-09-24/spring/">https://hyerin6.github.io/2021-09-24/spring/</a></li>
  <li>Spring Transaction으로 알아보는 AOP: <a href="https://hyerin6.github.io/2021-10-06/aop/">https://hyerin6.github.io/2021-10-06/aop/</a></li>
  <li>Ioc/DI: <a href="https://hyerin6.github.io/2020-01-31/spring-DI-IoC/">https://hyerin6.github.io/2020-01-31/spring-DI-IoC/</a></li>
  <li>AOP: <a href="https://hyerin6.github.io/2020-02-14/spring-AOP/">https://hyerin6.github.io/2020-02-14/spring-AOP/</a></li>
</ul>

<p><br />
<br /></p>

<h1 id="transactional-과-aop">Transactional 과 AOP</h1>

<p>Spring의 <code class="language-plaintext highlighter-rouge">@Transactional</code>은 어떻게 동작할까?</p>

<p><code class="language-plaintext highlighter-rouge">@Transactional</code> 어노테이션은 AOP를 사용하여 구현되는데</p>

<p>트랜잭션의 begin과 commit을 메인 로직 앞 뒤로 수행해주는 기능을 담당한다.</p>

<p><code class="language-plaintext highlighter-rouge">@Transactional</code>은 메서드가 실행되기 전 begin 메소드를 호출하고,</p>

<p>메소드가 종료된 후 commit을 호출한다.</p>

<p><br /></p>

<p>Spring AOP는 Proxy 패턴으로 구현되는데 Spring에서 사용하는 두 가지 프록시 구현체가 있다.</p>

<ul>
  <li>JDK Proxy (Dynamic Proxy)</li>
  <li>CGLib</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/33855307/136228333-728111ff-1cef-4718-8dea-72ff0ab9aa3c.png" alt="springaop-process" /></p>

<p><br /></p>

<p>JDK Proxy는 AOP를 적용하여 구현된 클래스의 인터페이스를 프록시 객체로 구현해서 코드를 끼워넣는 방식이다.</p>

<p>CGLib Proxy는 Class에 대한 Proxy생성을 지원한다. (상속을 이용)</p>

<p>따라서 final이나 private Method에 대한 AOP 불가능하다. (상속 된 Proxy 객체 생성 시, Override가 불가하기 때문이다.)</p>

<p><br /></p>

<p>스프링에 대해 공부하면서 클래스를 상속하는 것에 대해서 단점을 많이 알게 되었기 때문에</p>

<p>“CGLib는 필요 없는게 아닐까?” 라는 생각이 드는데</p>

<p>그렇지 않다. 단점이 있어도 상황에 따라 최선의 선택이 될 수도 있다.</p>

<p><br />
<br /></p>

<h1 id="jdk-proxy">JDK Proxy</h1>

<p>SpringBoot는 기본적으로 프록시 객체를 생성할 때 CGLib를 사용하고 있다.</p>

<p>그 이유는 JDK Proxy가 프록시를 생성할 때 내부적으로 <strong>Reflection</strong>을 사용하고 있기 때문이다.</p>

<p>리플렉션 자체가 비용이 비싼 API 이기도 하고 가급적 사용하지 않는 것을 추천하기 때문이다.</p>

<p>또한 JDK Proxy는 AOP 적용을 위해 반드시 인터페이스를 구현해야 한다는 단점도 있다.</p>

<p><br /></p>

<p>Dynamic Proxy는 <code class="language-plaintext highlighter-rouge">InvocationHandler</code>라는 인터페이스를 구현한다.
(JDK Proxy의 경우 자바에서 기본적으로 제공하고 있는 기능이다.)</p>

<p><code class="language-plaintext highlighter-rouge">InvocationHandler</code>의 <code class="language-plaintext highlighter-rouge">invoke</code> 메소드를 오버라이딩하여 proxy 위임 기능을 수행하는데</p>

<p>이때 메소드에 대한 명세와 파라미터를 가져오는 과정에서 리플렉션을 사용한다.</p>

<p><br />
<br /></p>

<h1 id="cglib">CGLib</h1>

<p>CGLib는 외부 3rd party library이며 JDK Proxy와는 달리 리플렉션을 사용하지 않고 바이트코드 조작을 통해 프록시 객체를 생성한다.</p>

<p>인터페이스를 구현하지 않고 해당 구현체를 상속받는 것으로 문제를 해결했기 때문에 성능상 이점도 있다.</p>

<p><br /></p>

<p>CGLib는 Enhance 라는 클래스를 바탕으로 proxy를 생성한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Enhancer</span> <span class="n">enhancer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Enhancer</span><span class="o">();</span>
<span class="n">enhancer</span><span class="o">.</span><span class="na">setSuperclass</span><span class="o">(</span><span class="nc">PostServiceImpl</span><span class="o">.</span><span class="na">class</span><span class="o">);</span> <span class="c1">// 프록시할 클래스 지정</span>
<span class="n">enhancer</span><span class="o">.</span><span class="na">setCallback</span><span class="o">(</span><span class="nc">NoOp</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span>

<span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">enhancer</span><span class="o">.</span><span class="na">create</span><span class="o">();</span> <span class="c1">// 프록시 생성 </span>
<span class="nc">PostServiceImpl</span> <span class="n">postService</span> <span class="o">=</span> <span class="o">(</span><span class="nc">PostServiceImpl</span><span class="o">)</span><span class="n">obj</span><span class="o">;</span>
<span class="n">postService</span><span class="o">.</span><span class="na">writePost</span><span class="o">(</span><span class="n">postDTO</span><span class="o">);</span> <span class="c1">// 프록시를 통한 간접 접근 </span>
</code></pre></div></div>

<p><br /></p>

<p>기본적으로 프록시 객체들은 직접 원본 객체를 호출하기 보다는 별도의 작업을 수행하는데</p>

<p>CGLib의 경우 callback을 사용한다.</p>

<p>CGLib에서 가장 많이 사용하는 콜백은 <code class="language-plaintext highlighter-rouge">net.sf.cglib.proxy.MethodInterceptor</code>이다.</p>

<p>프록시와 원본 객체 사잉에 인터셉터를 둬서 메소드 호출을 조작하는 것을 도와줄 수 있는 것이다.</p>

<p><code class="language-plaintext highlighter-rouge">PostServiceProxy</code> → <code class="language-plaintext highlighter-rouge">PostServiceInterceptor</code> → <code class="language-plaintext highlighter-rouge">PostServiceImpl</code></p>

<p><br />
<br /></p>

<h3 id="참고">참고</h3>

<ul>
  <li><a href="https://jaehun2841.github.io/2018/07/21/2018-07-21-spring-aop3/#spring-bean%EC%97%90-%EB%8C%80%ED%95%9C-proxy%EB%8A%94">https://jaehun2841.github.io/2018/07/21/2018-07-21-spring-aop3/#spring-bean%EC%97%90-%EB%8C%80%ED%95%9C-proxy%EB%8A%94</a></li>
  <li><a href="https://javacan.tistory.com/entry/114">https://javacan.tistory.com/entry/114</a></li>
</ul>

<p><br /></p>
:ET