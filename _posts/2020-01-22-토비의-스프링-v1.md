---
layout: post
title: "1장 오브젝트와 의존관계"
description: "토비의 스프링 vol 1"
date: 2020-01-22
tags: [spring]
comments: true
share: false
---

#### 1. 오브젝트와 의존관계     

**UserDao의 관심사항**      
- DB와 연결을 위한 커넥션을 어떻게 가져올까   
- SQL 문장을 담을 Statement를 만들고 실행   
- Statement와 Connection 오브젝트를 닫아 공유 리소스를 시스템에 돌려주기   

가장 큰 문제는 DB 커넥션을 가져오는 코드가 다른 관심사와 섞여 add() 메소드에 담겨 있고 동일한 코드가 get() 메소드에도 중복되어 있다는 점이다.   
앞으로 DAO 메소드가 늘어나게 되면,   
하나의 관심사가 방만하게 중복되어 있고 다른 관심의 대상과 얽혀 있어 변경이 일어나면 문제의 원인이 된다.   

**중복 코드의 메소드 추출**    
커넥션을 가져오는 중복된 코드를 분리하자.   
중복된 DB 연결 코드를 getConnection()이라는 독립적인 메소드로 만든다.   

**DB 커넥션 만들기의 독립**    
UserDao를 N사와 D사에 납품한다고 가정해보자.   
문제는 N사와 D사가 각기 다른 종류의 DB를 사용하고 있고, DB 커넥션을 가져오는 데 있어 독자적인 방법을 적용허고 싶어 한다는 점이다.  
이러한 경우 UserDao의 소스코드를 고객에게 제공하지 않을 것이라면 어떻게 고객 스스로   
원하는 DB 커넥션 생성 방식을 적용해가면서 UserDao를 사용하게 할 수 있을까?    

**상속을 통한 확장**    
UserDao에서 메소드의 구현 코드를 제거하고 getConnection()을 추상 메소드로 만들어 놓는다.   
추상 메소드라서 메소드 코드는 없지만 메소드 자체는 존재한다. 따라서 add(), get() 메소드에서 getConnection()을 호출하는 코드는 그대로 유지할 수 있다.   
N사와 D사에서 UserDao를 구입한 포탈사들은 UserDao 클래스를 상속해서 각각 NUserDao와 DUserDao라는 서브클래스를 만들어 getConnection() 메소드를   
원하는 방식대로 구현할 수 있다.    

상속을 통해 확장하면, DAO의 핵심 기능인 '어떻게 데이터를 등록하고 가져올 것인가'      
라는 관심을 담고 있는 NUserDao, DUserDao가 클래스 레벨로 구분이 되고 있다.     
클래스 계층구조를 통해 두 개의 관심이 독랍적으로 분리되면서 변경 작업이 용이해졌다.   
새로운 DB 연결 방법을 적용해야 할 때는 UserDao를 상속을 통해 확장해주기만 하면 된다.   

이렇게 슈퍼클래스에 기본적인 로직의 흐름(커넥션 가져오기, SQL 생성, 실행, 반환)을 만들고, 그 기능의 일부를 추상 메소드나   
오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 벙법을 디자인 패턴에서   
템플릿 메소드 패턴이라고 한다.     
UserDao의 getConnection() 메소드는 Connection 타입 오브젝트를 생성한다는 기능을 정의해놓은 추상 메소드이다.   
그리고 어떤 Connection 클래스의 오브젝트를 어떻게 생성할 것인지를 결정하는 방법이라고도 볼 수 있다.      
이렇게 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 팩토리 메소드 패턴이라고 부르기도 한다.     
NUserDao와 DUserDao가 모든 같은 종류의 Connection 구현 클래스의 오브젝트를 리턴하더라도 오브젝트를 생성하는 방식이 다르다면,   
이는 팩토리 메소드 패턴으로 이해할 수 있다.       

하지만 이 방법은 상속을 사용했다는 단점이 있다. 상속 자체는 간단해 보이고 사용하기도 편리하게 느껴지지만 한계점이 있다.   
자바는 다중상속을 허용하지 않기 때문에 후에 다른 목적으로 UserDao에 상속을 적용하기 힘들고 이미 상속을 사용하고 있다면 ?    
또 다른 문제는 상속을 통한 상하위 클래스의 관계는 생각보다 밀접하다는 점이다.   
상속을 통해 관심이 다른 기능을 분리하고, (필요에 따라 변경이 가능하게)확장성도 줬지만 상속관계는 두 가지 다른 관심사에 대해 긴밀한 결합을 허용한다.   
서브클래스는 슈퍼클래스의 기능을 직접 사용할 수 있다. 그래서 슈퍼클래스의 내부 변경이 있는 경우 모든 서브클래스를 함께 수정하거나 다시 개발해야 할 수도 있다.   

확장된 기능인 DB 커넥션을 생성하는 코드를 다른 DAO 클래스에 적용할 수 없다는 것도 큰 단점이다.   

**DAO의 확장**    
위에서 두 개의 관심을 상하위 클래스로 분리시켰다. 이 두 개의 관심은 변화의 성격이 다르다.   
변화의 성격이 다르다는 건 변화의 이유와 시기, 주기 등이 다르다는 것이다.   

- 클래스의 분리   
DB 커넥션과 관련된 부분을 서브클래스가 아니라, 아예 별도의 클래스인 SimpleConnectionMaker에 담는다.  
UserDao는 new 키워드를 사용해 오브젝트를 만들어두고 이를 add(), get() 메소드에서 사용한다.   
</br></br>        
문제(1) : N 사와 D 사에 UserDao 클래스만 공급하고 상속을 통해 DB 커넥션을 확장해서 사용했던 게 다시 불가능해짐   
이유 : UserDao의 코드가 SimpleConnectionMaker라는 특정 클래스에 종속되어 있기 때문이다.   
즉, UserDao 코드의 수정 없이 DB 커넥션 생성 기능을 변경할 방법이 없다.    
</br></br>       
문제(2) : DB 커넥션을 제공하는 클래스가 어떤 것인지를 UserDao가 구체적으로 알고 있어야 한다.   
이유 : 문제(1)과 같은 이류로 UserDao가 DB 커넥션을 가져오는 구체적인 방법에 종속되어 버리기 떄문이다.   

- 인터페이스 도입   
가장 좋은 해결책은 두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리를 만들어 주는 것이다.   
추상화란 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리하는 작업이다.   
자바가 추상화를 위해 제공하는 가장 유용한 도구는 바로 인터페이스이다. 인터페이스는 자신이 구현한 클래스에 대해 구체적인 정보는 모두 감춘다.   
오브젝트를 만들려면 구체적인 클래스 하나를 선택해야겠지만,     
인터페이스로 추상화해놓은 최소한의 통로를 통해 접근하는 쪽에서는 오브젝트를 만들 때 사용할 클래스가 무엇인지 몰라도 된다.      
</br></br>
문제 : ```connectionMaker = new DConnectionMaker();``` 초기에 한 번 어떤 클래스의 오브젝트를 사용할지 결정하는 생성자의 코드가 남아 있다.     

- 관계설정 책임의 분리    
인터페이스를 써서 관심을 분리했는데 왜 아직도 UserDao가 인터페이스뿐 아니라 구체적인 클래스까지 알아야할까?   
```new DConnectionMaker();``` 이 코드는 충분히 독립적인 관심사를 담고 있기 때문이다.   
바로 UserDao가 어떤 ConnectionMaker 구현 클래스의 오브젝트를 이용하게 할지를 결정하는 것이다.   
UserDao와 UserDao가 사용할 ConnectionMaker릐 특정 구현 클래스 사이의 관계를 설정해주는 것에 관한 관심이다.   
</br></br>        
UserDao를 사용하는 클라이언트가 존재할 것인데, 
여기서 말하는 클라이언트는 한 오브젝트가 다른 오브젝트의 기능을 사용한다면, 사용되는 쪽이 사용하는 쪽에게 서비스를 제공하는 셈이다.     
UserDao의 클라이언트가 제3의 관심사항인 UserDao와 ConnectionMaker 구현 클래스의 관계를 결정해주는 기능을 분리해서 두기 적절한 곳이다.   
</br></br>   
UserDao 오브젝트와 특정 클래스로부터 만들어진 ConnectionMaker 오브젝트 사이에 관계를 설정해 주는 것이다.   
클래스 사이에 관계가 만들어진다는 것은 한 클래스가 인터페이스 없이 다른 클래스를 직접 사용한다는 뜻이다.   
따라서 클래스가 아니라 오브젝트와 오브젝트 사이의 관계를 설정해줘야 한다.    
오브젝트 사이의 관계는 런타임 시에 한쪽이 다른 오브젝트의 레퍼런스를 갖고 있는 방식으로 만들어진다.     
'사용'이라는 관계를 맺게 해주자!    
</br></br>    
직접 생성자를 호출해서 직접 오브젝트를 만드는 방법도 있지만 외부에서 만들어준 것을 가져오는 방법도 있다.   
메소드 파라미터나 생성자 파라미터를 이용하면 된다.     
</br></br>    
위 방법은 클래스 사이에 관계가 만들어진 것은 아니고, 단지 오브젝트 사이에 다이내믹한 관계가 만들어지는 것이다.       
(클래스 사이의 관계는 코드에 다른 클래스 이름이 나타나기 떄문에 만들어지는 것이다. 오브젝트 사이의 관계는 그렇지 않다.)   
이는 객체지향 프로그램에 다형성이라는 특징이 있는 덕분이다!    
 
**제어의 역전(IoC)**   
- 오브젝트 팩토리     
앞에서 UserDaoTest에 어떤 ConnectionMaker 구현 클래스를 사용할지 결정하는 기능을 떠넘겼다.   
분리시킬 기능을 담당할 클래스를 하나 만들어보자!    
이 클래스의 역할은 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것인데, 이런 일을 하는 오브젝트를 흔히 팩토리라고 부른다.   
이는 디자인 패턴에서 말하는 추상 팩토리 패턴이나 팩토리 메소드 패턴과는 다르다.   
단지 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 깔끔하게 분리하려는 목적으로 사용하는 것이다.   
</br></br>      
UserDao, ConnectionMaker 관련 생성 작업을 DaoFactory로 옮기고,    
UserDaoTest에서는 DaoFactory에 요청해서 미리 만들어진 UserDao 오브젝트를 가져와 사용하게 만든다.      

- 설계도로서의 팩토리   
UserDao, ConnectionMaker : 각각 애플리케이션의 핵심적인 데이터 로직과 기술 로직을 담당 - 실직적인 로직을 담당하는 컴포넌트   
DaoFactory : 애플리케이션의 오브젝트들을 구성하고 그 관계를 정의하는 책임을 맡음 - 애플리케이션을 구성하는 컴포넌트의 구조와 관계를 정의한 설계도   
</br></br>            
DaoFactory를 분리했을 때 장점은 매우 다양하다.     
애플리케이션의 컴포넌트 역할을 하는 오브젝트와 애플리케이션의 구조를 결정하는 오브젝트를 분리했다는 데 가장 의미가 있다.      


 