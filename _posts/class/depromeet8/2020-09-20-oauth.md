---
layout: post
title: "OAuth 2.0"  
description: "OAuth2 In Action 참고"
date: 2020-09-20
tags: [depromeet]
categories: [Depromeet]
comments: true
share: true
--- 

## OAuth 2.0 인가 그랜트 절차      

(웹 클라이언트라고 가정)     

<br />    

**1.** 클라이언트는 자신이 원하는 것에 접근하기 위해 새로운 OAuth 액세스 토큰이 필요하다고 인지하면 리소스 소유자의 권한 일부를 자신에게 위임해달라고 요청하기 위해 리소스 소유자를 인가 서버의 인가 엔드 포인트로 리다이렉트시킨다.      
(ENDPOINT란 API가 서버에서 리소스에 접근할 수 있도록 가능하게 하는 URL이다.)        

위 응답 내용은 웹 브라우저가 인가 서버에 HTTP GET 요청을 보내도록 만든다.      

<br />    

**2.** 인가 서버는 일반적으로 사용자 인증을 요구한다. 이 과정을 통해 리소스 소유자가 누구인지 판단하고 해당 사용자가 클라이언트에게 어떤 권한을 위임해줄 수 있는지 확인한다.      
사용자의 인증 정보는 사용자와 인가 서버 간에 직접 전달되고 클라이언트는 사용자의 인증 정보를 볼 수 없다.        
그렇게 함으로써 사용자의 자격 증명이 클라이언트에게 공유되는 것을 방지한다.                

<br />    

**3.** 사용자는 클라이언트 애플리케이션을 인가한다.            
이 단계에서 리소스 소유자는 클라이언트에게 자신의 권한 일부를 위임할 것인지 선택한다.            

인가 서버는 사용자가 클라이언트가 요청한 권한 전체, 일부를 거부하거나 요청된 권한 범위를 모두 승인할 수 있는 방법을 제공한다.             

<br />    

**4.** 인가 서버가 사용자를 클라이언트 애플리케이션으로 리다이렉트시키며 인가 코드를 전달한다.                    
즉, 클라이언의 redirect_uri로 HTTP 리다이렉트된다.                

주목할 점은 이 HTTP 요청이 인가 서버가 아닌 클라이언트에게 전달된다는 것이다.           
인가 코드 그랜트 유형은 HTTP 요청에 code라는 특별한 질의 파라미터가 포함된다.               
해당 파라미터는 인가 코드라는 일회용 자격 증명 데이터로서 사용자가 클라이언트에게 권한을 위임했음을 나타낸다.             
HTTP 요청이 클라이언트에게 전달되면 클라이언트는 전달된 파라미터를 분석해 인가 코드 값을 추출하고 이후의 단계에 그것을 이용하고 클라이언트는 state 파라미터 값이 이전에 자신이 보낸 것과 동일한 것인지 확인한다.              

<br />    

**5.** 클라이언트가 인가 코드를 획득하면 그것을 다시 인가 서버의 토큰 엔드 포인트로 전달한다.          
전달하고자 하는 파라미터를 HTTP POST로 전달하고, client_id와 client_secret는 HTTP Basic 인가 헤더로 전달한다.      
이 요청은 웹 브라우저나 리소스 소유자와는 상관없이 클라이언트와 인가 서버 사이에 직접 이뤄진다.    
따라서 클라이언트는 직접 인증을 요청할 수 있고, 다른 구성 요소가 클라이언트의 토큰 요청 질의를 보거나 조작할 수 없다.      

<br />    

**6.** 인가 서버는 전달된 클라이언트의 토큰 요청이 유효하면 토큰을 발급한다.         
인가서버는 새로운 액세스 토큰을 생성해 그것을 해당 클라이언트에게 전달한다. 토큰은 JSON 객체 형태로 HTTP 웅답안에 포함돼 전달된다.         

<br />    

**7.** 클라이언트는 토큰 응답을 분석해 액세스 토큰 값을 추출하고 그것을 이용해 보호된 리소스에 접근한다.         
클라이언트가 액세스 토큰을 전달하는 방법 중 권장하는 방법은 Authorization 헤더를 이용하는 방법이다.          
 
<br />    
 
**8.** 보호된 리소스는 헤더에서 전달된 토큰을 추출하고 다음 목록을 확인한다. 
- 토큰이 유효한지   
- 연관된 정보   
- 누가 인가했는지   
- 무엇을 위해 인가됐는지     

그 다음에는 요청에 대한 적절한 응답을 전달한다.   


<br />     
<br />         


## OAuth의 구성원과 구성 요소 간의 상호 작용    
: 백 채널， 프런트 채널, 엔드 포인트      

OAuth 프로세스의 많은 부분이 HTTP 요청과 응답으로 구성 요소 간의 통신이 이뤄진다.   
그러나 항상 단순한 HTTP 요청과 응답으로 이뤄지는건 아니다.   


(1) 백 채널 통신   
HTTP 요청과 응답으로 구성 요소 간의 통신이 이뤄지는 것을 백 채널 통신이라고 한다.   
즉 헤더, 파라미터, 메서드, 요청 내용에 중요한 트랜잭션 정보가 포함된다.   

인가 서버는 클라이언트가 액세스 토큰과 리프레시 토큰을 요청하기 위해 사용하는 토큰 엔드 포인트를 제공한다.   
클라이언트는 토큰 엔드 포인트를 직접 호출하며, 인가 서버가 분석하고 처리할 수 있는 인코딩된 폼 파라미터 형태로 요청 내용을 전달한다.     
그 후 인가 서버는 JSON 객체 형식의 토큰을 응답으로 전달한다.   

클라이언트가 보호된 리소스에 접근할 때도 백 채널 통신으로 HTTP를 직접 호출한다.           
백 채널은 브라우저를 제외한 구성 요소 간의 직접적인 HTTP 연결이다.          


(2) 프런트 채널 통신   
서버는 전달된 정보의 내용을 보고 해당 요청에 대해 어떻게 응답할 것인지 결정한다.   
하지만 OAuth에서는 두 구성 요소가 직접 HTTP 요청을 보내고 응답을 받지 않는 경우가 있다.   
즉 클라이언트가 인가 서버의 인가 엔드 포인트와 상호 작용하는 경우이다.   
프런트 채널 통신은 중간의 웹 브라우저를 통해 두 시스템이 간접적으로 HTTP 통신을 하는 방법이다.    

이 기술은 웹 브라우저의 양쪽 세션을 분리하며, 그로 인해 서로 다른 보안 도메인 간의 작업을 가능하게 해준다.    
그렇다면 두 소프트웨어가 서로 간의 대화 없이 어떻게 통신할 수 있을까?    
프런트 채널 통신은 웹 브라우저가 방문해야 하는 URL을 파라미터로 전달함으로써 이뤄진다.     
그런 URL을 전달받은 쪽에서는 해당 URL을 파싱하고 함께 전달된 파라미터와 동일한 방법으로 웹 브라우저를 해당 URL로 리다이렉트한다.       


**요약**     
OAuth의 구성 요소는 서로 간의 통신을 위해 직접적(백 채널), 간접적(프런트 채널)인 HTTP 통신을 수행한다.       


<br />       
<br />         

## OAuth 토큰     

공유해 사용하는 데이터베이스에서 토큰을 찾는 것 대신 토큰 안에 필요한 정보를 담아 만들면 인가 서버는 어떤 네트워크 API 호출 없이도 토큰 자체 만으로 보호된 리소스와 간접적으로 통신할 수 있게 된다.   

이 경우 필요한 정보가 담긴 토큰은 클라이언트에게 전달되지만, 모든 OAuth 2.0 시스템에서는 토큰의 구조가 불명확한 상태로 유지되기 때문에 클라이언트는 토큰의 내용을 알지 못한다.   

이와 같은 종류의 토큰을 만들기 위해서는 전달할 정보를 구조화하고 직렬화하는 방법이 필요하다.   
JSON 웹 토큰 포맷 또는 JWT는 토큰을 전달해야 하는 정보를 간단히 구조화하는 방법을 제공한다.   



<br />        


