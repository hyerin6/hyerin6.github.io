---
layout: post
title: "토비의 스프링 (6-1)"  
description: "AOP" 
date: 2020-06-14
tags: [spring]
comments: true
share: true
---

## 다이내믹 프록시와 팩토리 빈   

#### (1) 프록시와 프록시 패턴, 테코레이터 패턴   

트랜잭션 경계설정 코드를 비즈니스 로직 코드에서 분리해낼 때 적용했던 기법을 다시 생각해보자.    

단순히 확장성을 고려해서 한 가지 기능을 분리한다면   
전형적인 전략패턴을 사용하면 된다.   

전략패턴으로는 트랜잭션 기능의 구현 내용을 분리해냈을 뿐   
트랜잭션을 적용한다는 사실은 코드에 그대로 남아 있다.   

트랜잭션이라는 기능은 사용자 관리 비스니스 로직과는 성격이 다르기 때문에   
아예 그 적용 사실 자체를 밖으로 분리할 수 있다.   
이 방법을 이용해 `UserServiceTx`를 만들었고 `UserServiceImpl`에는 트랜잭션 관련 코드가 없다.   

이렇게 분리된 부가기능을 담은 클래스는 중요한 특징이 있다.   
부가기능 이외 나머지 모든 기능은 원래 핵심기능을 가진 클래스로 위임해줘야 한다.   
핵심기능은 부가기능을 가진 클래스의 존재 자체를 모른다.   
따라서 부가기능이 핵심기능을 사용하는 구조가 되는 것이다.   

문제는 이렇게 구성했더라도 클라이언트가 핵심기능을 사진 클래스를 직접 사용해버리면   
부가기능이 적용될 기회가 없다는 점이다.   
그래서 부가기능은 마치 자신이 핵심기능을 가진 클래스인 것처럼 꾸며서 클라이언트가 자신을 거쳐서   
핵심기능을 사용하도록 만들어야 한다.   

그러기 위해서는 클라이언트는 인터페이스를 통해서만 핵심기능을 사용하게 하고,   
부가기능 자신도 같은 인터페이스를 구현한 뒤에 자신이 그 사이에 끼어들어야 한다.   
그러면 클라이언트는 인터페이스만 보고 사용하기 때문에 자신은 핵심기능을 가진 클래스를 사용한다고 생각하지만   
사실은 부가기능을 통해 핵심기능을 이용하게 되는 것이다.   

이렇게 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 
클라이언트의 요청을 받아주는 것을 대리자, 대리인 같은 역할을 한다고 해서 프록시라고 부른다.   

그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃 또는 실체라고 부른다.   

**클라이언트 -> 프록시 -> 타깃**   

프록시의 특징은 타깃과 같은 인터페이스를 구현했다는 것과 프록시가 타깃을 제어할 수 있는 위치에 있다는 것이다.      
 
프록시는 사용 목적에 따라 두 가지로 구분될 수 있다.            
1. 클라이언트가 타깃에 접근하는 방법을 제어하기 위해서    
2. 타깃에 부가적인 기능을 부여해주기 위해서   

두 가지 모두 대리 오브젝트라는 개념의 프록시를 두고 사용한다는 점은 동일하지만,         
목적에 따라 디자인 패턴에서는 다른 패턴으로 구분한다.          


**- 데코레이터 패턴**    
 
데코레이터 패턴은 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴을 말한다.     
다이내믹하게 기능을 부여한다는 의미는 컴파일 시점, 
즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않다는 의미이다.       

데코레이터 패턴은 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법이다.   



**- 프록시 패턴**  

일반적으로 사용하는 프록시라는 용어와 디자인 패턴에서 말하는 프록시 패턴은 구분할 필요가 있다.   

프록시 : 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝트를 두는 방법을 총칭   
프록시 패턴 : 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우   

<br/>   

프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않는다.    
대신 클라이언트가 타깃에 접근하는 방식을 변경해준다.    

타깃 오브젝트는 꼭 필요한 시점까지 생성하지 않는 것이 좋다.     
그런데 타깃 오브젝트에 대한 레퍼런스가 미리 필요할 수가 있다.    
이런 경우 프록시 패턴을 적용하면 된다.     
실제 타깃 오브젝트는 만드는 대신 프록시를 넘겨주는 것이다.     
그리고 프록시의 메소드를 통해 타깃을 사용하려고 시도하면    
그때 프록시가 타깃 오브젝트를 생성하고 요청을 위임해주는 식이다.     

이렇게 프록시를 통해 생성을 최대한 늦춤으로써 얻는 장점이 많다.   

<br/>   

또는 특별한 상황에서 타깃에 대한 접근권한을 제어하기 위해 프록시 패턴을 사용할 수 있다.   
    
특정 레이어로 넘어가서는 읽기전용으로만 동작하게 강제해야 한다고 가정하자.        
이런 경우 오브젝트의 프록시를 만들어서 사용할 수 있다.     
프록시의 특정 메소드를 사용하려고 하면 접근이 불가능하다고 예외를 발생시키면 된다.   

이렇게 프록시 패턴은 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 이용한다는 것이다.    

<br/>   

구조적으로 보면 프록시와 데코레이터는 유사하다.   
다만 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많다.   
생성을 지연하는 구체적인 생성 방법을 알아야 하기 때문이다.   
물론 인터페이스를 통해 위임하도록 구현할 수도 있다.    

<br/>   


#### (2) 다이내믹 프록시   

프록시는 기존 코드에 영향을 주지 않으면서 타깃의 기능을 확장하거나 접근 방법을 제어할 수 있는 유용한 방법이다.   

하지만 매번 새로운 클래스를 생성하고, 인터페이스로 구현해야 할 때 메소드가 많으면 모든 메소드를 일일이 구현해서  
위임하는 코드를 넣어야해서 불편해하는 개발자들도 있다.     

자바 java.lang.reflect 패키지 안에 프록시를 손쉽게 만들 수 있도록 지원해주는 클래스들이 있다.     
몇 가지 API를 이용해 프록시처럼 동작하게 하는 오브젝트를 다이내믹하게 생성하는 것이다.       


**- 프록시의 구성과 프록시 작성의 문제점**   

프록시는 다음의 두 가지 기능으로 구성된다.   

1. 타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임한다.   

2. 지정된 요청에 대해서는 부가기능을 수행한다.   

이렇게 프록시의 역할은 위임과 부가작업이라는 두 가지로 구분할 수 있다.   
그렇다면 프록시를 만드는게 번거로운 이유는 뭘까?   

다음과 같은 두 가지 이유가 있다. 

1. 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거롭다.     

2. 부가기능 코드가 중복될 가능성이 많다. 트랜잭션은 DB를 사용하는 대부분의 로직에 적용될 필요가 있다.   
메소드가 많아지고 트랜잭션 적용의 비율이 높아지면 트랜잭션 기능을 제공하는 유사한 코드가 여러 메소드에 중복되어 나타날 것이다.   

바로 이런 문제들을 해결하는 데 유용한 것이 JDK의 다이내믹 프록시다.   


**- 리플렉션**    

다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어준다.    
리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든 것이다.   

리플렉션 API 중에서 메소드에 대한 정의를 담은 Method라는 인터페이스를 이용해 메소드를 호출하는 방법을 알아보자.   


```java  
Method lengthMethod = String.class.getMethod("length");  
```  

위 코드는 String 이 가진 메소드 중에서 length 라는 이름을 갖고 있고,   
파라미터가 없는 메소드의 정보를 가져오는 것이다.       

이를 이용해 특정 오브젝트의 메소드를 실행시킬 수도 있다.   
Method 인티페이스에 정의된 invoke() 메소드를 사용하면 된다.   

invoke() 메소드는 메소드를 실행시킬 대상 오브젝트와 파라미터 목록을 받아서   
메소드를 호출한 뒤에 그 결과를 Object 타입으로 돌려준다.       


```java    
int length = lengthMethod.invoke(name); // int length = name.length();  
```  



**- 다이내믹 프록시 적용**       

다이내믹 프록시를 이용한 프록시를 만들어보자.       
다이내믹 프록시가 동작하는 방식은 다음과 같다.   


<br/>    

![스크린샷 2020-06-14 오후 9 11 09](https://user-images.githubusercontent.com/33855307/84592866-a2976100-ae83-11ea-86e9-66600977fb4c.png)    

<br/>       

  
다이내믹 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트다.   
다이내믹 프록시 오브젝트는 타깃의 인터페이스와 같은 타입으로 만들어진다.   
클라이언트는 다이내믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있다.   
이 덕분에 프록시를 만들 때 인터페이스를 모두 구현해가면서 클래스를 정의하는 수고를 덜 수 있다.     
프록시 팩토리에게 인터페이스 정보만 제공해주면 해당 인터페이스를 구현한 클래스의 오브젝트를 자동으로 만들어주기 때문이다.   

다이내믹 프록시가 인터페이스 구현 클래스의 오브젝트는 만들어쥦만, 프록시로서 필요한 부가기능 제공 코드는 직접 작성해야 한다.    
부가기능은 프록시 오브젝트와 독립적으로 `InvocationHandler`를 구현한 오브젝트에 담는다.   
`InvocationHandler`는 다음과 같은 메소드 한 개만 가진 간단한 인터페이스다.   


```java  
public Object invoke(Object proxy, Method method, Object[] args)  
```  

invoke() 메소드는 리플렉션의 Method 인터페이스를 파라미터로 받는다.    
메소드를 호출할 때 전달되는 파라미터도 args로 받는다. 
다이내믹 프록시 오브젝트는 클라이언트의 모든 요청을 리플렉션 정보로 변환해서       
InvocationHandler 구현 오브젝트의 invoke() 메소드로 넘기는 것이다.          
타깃 인터페이스의 모든 메소드 요청이 하나의 메소드로 집중되기 때문에 중복되는 기능을 효과적으로 제공할 수 있다.   

리플렉션으로 메소드와 파라미터 정보를 모두 갖고 있으므로 타깃 오브젝트의 메소드를 호출하게 할 수도 있다.     
InvocationHandler 구현 오브젝트가 타깃 오브젝트의 레퍼런스를 갖고 있다면   
리플렉션을 이용해 간단히 위임 코드를 만들어낼 수 있다.     
 
즉 InvocationHandler 구현 오브잭트는 다이내믹 프록시로부터 전달받은 요청을         
다시 타깃 오브젝트에 위임해야 하기 떄문에 타깃 오브젝트를 주입받아 둬야 한다.             


다음은 다이내믹 프록시를 생성하는 코드다.   

```java    
Hello proxiedHello = (Hello)Proxy.newProxyInstance(
        getClass().getClassLoader(),
        new Class[] { Hello.class },
        new UpperCaseHandler(new HelloTarget()))
);
```


`(Hello)Proxy.newProxyInstance(`       
생성된 다이내믹 프록시 오브젝트는 Hello 인터페이스를 구현하고 있으므로 Hello 타입으로 캐스팅해도 안전하다.   


`getClass().getClassLoader()`   
동적으로 생성되는 다이내믹 프록시 클래스의 로딩에 사용할 클래스 로더   


`new Class[] { Hello.class }`   
구현할 인터페이스      


`new UpperCaseHandler(new HelloTarget()))`     
부가기능과 위임 코드를 담은 invocationHandler 
 
<br/>       

사용 방법을 자세하게 알아보자.   

첫 번째 파라미터는 클래스 로더를 제공해야 한다.    
다이내믹 프록시가 정의되는 클래스 로더를 지정하는 것이다.   

두 번째 파라미터는 다이내믹 프록시가 구현해야 할 인터페이스다.   
다이내믹 프록시는 한 번에 하나 이상의 인터페이스를 구현할 수도 있다.   
따아서 인터페이스의 배열을 사용한다.   

마지막 파라미터로는 부가기능과 위임 관련 코드를 담고 있는 InvocationHandler 구현 오브젝트를 제공해야 한다.        


newProxyInstance()에 의해 만들어지는 다이내믹 프록시 오브젝트는      
파라미터로 제공한 Hello 인터페이스를 구현한 클래스의 오브젝트이기 때문에 Hello 타입으로 캐스팅이 가능하다.     

UppercaseHandler를 사용하는 Hello 인터페이스를 구현한 다이내믹 프록시가 만들어졌으니    
Hello 인터페이스를 통해서 사용하면 된다.    


<br/>       

**- 다이내믹 프록시의 확장**   

만약 인터페이스의 메소드가 30개로 늘어난다면?      

클래스로 직접 구현한 프록시는 매번 코드를 추가해야 한다.      
그러나 UppercaseHandler와 다이내믹 프록시를 생성해서 사용하는 코드는 전혀 손댈 게 없다.   

다이내믹 프록시가 만들어질 때 추가된 메소드가 자동으로 포함될 것이고 부가기능은 invoke() 메소드에서 처리되기 때문이다.   


InvocationHandler 방식의 또 한 가지 장점은 타깃의 종류에 상관없이 적용이 가능하다는 점이다.   
어차피 리플렉션의 Method 인터페이스를 이용해 타깃의 메소드를 호출하는 것이니 제한할 필요가 없다.   
어떤 종류의 인터페이스를 구현한 타깃이든 상관없이 재사용할 수 있다.   




<br/>       



#### (3) 다이내믹 프록시를 이용한 트랜잭션 부가기능    

UserServiceTx를 다이내믹 프록시 방식으로 변경하기 위해 TransactionHandler를 구현하고     
타깃 오브젝트와 트랜잭션 매니저, 메소드 패턴을 주입해준다.   
이후 TransactionHandler 오브젝트를 이용해 UserService 타입의 다이내믹 프록시를 생성하면 된다.   


<br/>       


#### (4) 다이내믹 프록시를 위한 팩토리 빈    

이제 TransactionHandler와 다이내믹 프록시를 스프링의 DI를 통해 사용할 수 있도록 만들어야 할 차례다.     
그런데 문제는 DI의 대상이 되는 다이내믹 프록시 오브젝트는 일반적인 스프링의 빈으로는 등록할 방법이 없다는 것이다.     

스프링은 지정된 클래스 이름을 가지고 리플렉션을 이용해서 래당 클래스의 오브젝트를 만든다.     
스프링은 내부적으로 리플렉션 API를 이용해서 빈 정의에 나오는 클래스 이름을 가지고 빈 오브젝트를 생성한다.   

그러나 사전에 프록시 오브젝트의 클래스 정보를 미리 알아내서 스프링의 빈을 정의할 방법이 없다.     
다이내믹하게 새로 정의해서 사용하고 다이내믹 프록시 오브젝트의 클래스가 어떤 것인지 알 수도 없기 때문이다.    
다이내믹 프록시는 Proxy 클래스의 newProxyInstance() 라는 스태틱 팩토리 메소드를 통해서만 만들 수 있다.   

<br/>       

**- 팩토리 빈**     

스프링은 클래스 정보를 가지고 디폴트 생성자를 통해 오브젝트를 만드는 방법 외에도 빈을 만들 수 있는 여러 가지 방법을 제공한다.   
대표적으로 팩토리 빈을 이용한 빈 생성 방법을 들 수 있다.   
팩토리 빈이란 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈을 말한다.   

가장 간단한 방법은 FactoryBean 인터페이스를 구현하는 것이다.     
FactoryBean 인터페이스를 구현한 클래스를 스프링의 빈으로 등록하면 팩토리 빈으로 동작한다.     


먼저 스프링에서 빈 오브젝트로 만들어 사용하고 싶은 클래스를 하나 정의해보자.   


```java           
public class Message {
    String text;
    
    private Message(String text) {
        this.text = text;
    }

    public static Message newMessage(String text) {
        return new Message(text);
    }
}
```



Message 클래스의 오브젝트를 만들려면 newMessage() 라는 스태틱 메소드를 사용해야 한다.     
따라서 이 클래스를 직접 스프링 빈으로 등록해서 사용할 수 없다.       

사실 스프링은 private 생성자를 가진 클래스도 빈으로 등록해주면 리플렉션을 이용해서 오브젝트를 만들어준다.     
리플렉션은 private 으로 선언된 접근 규약을 위반할 수 있기 때문이다.     
그러나 이를 무시하고 오브젝트를 강제로 생성하는 것은 위험하다.       


```java    
public class MessageFactoryBean implements FactoryBean<Message> {

    String text;
    
    public Message getObject() throws Exception {
        return Message.newMessage(this.text);
    }

    public Message getObject() throws Exception {
        return Message.class;   
    }
    
    public boolean isSingleTon() {
        return false;
    }

}
```   

팩토리 빈은 전형적인 팩토리 메소드를 가진 오브젝트다.   
스프링은 FactoryBean 인터페이스를 구현한 클래스가 빈의 클래스로 지정되면,     
팩토리 빈 클래스의 오브젝트의 getObject() 메소드를 이용해 오브젝트를 가져오고   
이를 빈 오브젝트로 사용한다.   

빈의 클래스로 등록된 팩토리 빈은 빈 오브젝트를 생성하는 과정에서만 사용될 뿐이다.    


스프링 빈에는 팩토리 빈과 타깃 클래스만 빈으로 등록한다.       
팩토리 빈은 다이내믹 프록시가 위임할 타깃 오브젝트에 대한 레퍼런스를 프로퍼티를 통해 DI 받아둬야 한다.    


<br/>       


#### (5) 프록시 팩토리 빈 방식의 장점과 한계   

다이내믹 프록시를 생성해주는 팩토리 빈을 사용하는 방법은 여러 가지 장점이 있다.   
한번 부가기능을 가진 프록시를 생성하는 팩토리 빈을 만들어두면 타깃의 타입에 상관없이 재사용할 수 있기 때문이다.      
 

**- 프록시 팩토리 빈의 장점**    

데코레이터 패턴이 적용된 프록시를 사용하면 많은 장점이 있음에도 적극적으로 활용하지 못하는 두 가지 문제점이 있었다.   

1. 프록시를 적용할 대상이 구현하고 있는 인터페이스를 구현하는 프록시 클래스를 일일이 만들어야 한다.   
2. 부가적인 기능이 여러 메소드에 반복적으로 나타나게 돼서 코드 중복의 문제가 발생한다.   

지금까지 공부한 프록시 팩토리 빈은 이 두 가지 문제를 해결해준다.       


**- 프록시 팩토리 빈의 한계**      

프록시를 통해 타킷에 부가기능을 제공하는 것은 메소드 단위로 일어나는 일이다.   
하나의 클래스 안에 존재하는 여러 개의 메소드에 부가기능을 한 번에 제공하는 것은 가능하지만     
한 번에 여러 개의 클래스에 공통적인 부가기능을 제공하는 것은 지금까지 공부한 방법으로는 불가능하다.     

트랜잭션과 같이 비즈니스 로직을 담은 많은 클래스의 메소드에 적용할 필요가 있다면 
거의 비슷한 프록시 팩토리 빈의 설정이 중복되는 것을 막을 수 없다.   

설정파일이 급격히 복잡해지는 것은 바람직하지 못하다.      
게다가 타깃과 인터페이스만 다른, 거의 비슷한 설정이 반복된다는 것이 찜찜하다.   


또 한 가지 문제점은 TransactionHandler 오브젝트가 프록시 팩토리 빈 개수만큼 만들어진다는 것이다.   
TransactionHandler는 타깃 오브젝트를 프로퍼티로 갖고 있다.   
따라서 트랜잭션 부가기능을 제공하는 동일한 코드임에도 불구하고 타깃 프로젝트가 달라지면   
새로운 TransactionHandler 오브젝트를 만들어야 한다.   



이러한 문제도 해결해보자.   



<br/>    



