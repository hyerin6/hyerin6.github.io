---
layout: post
title: "토비의 스프링 (6-2)"  
description: "AOP 2" 
date: 2020-06-14
tags: [spring]
comments: true
share: true
---


# 스프링의 프록시 팩토리 빈     

지금까지 트랜잭션 부가기능을 추가해줄 수 있는 다양한 방법을 찾아봤다.     
아직 해결해야 할 문제들이 있는데 스프링은 깔끔하게 해법을 제공한다고 한다.   


### 1. ProxyFactoryBean    

스프링은 일관된 방법으로 프록시를 만들 수 있게 도와주는 추상 레이어를 제공한다.   
생성된 프록시는 스프링의 빈으로 등록돼야 한다. 스프링은 프록시 오브젝트를 생성해주는 기술을 추상화한 팩토리 빈을 제공해준다.   

ProxyFactoryBean이 생성하는 프록시에서 사용할 부가기능은 MethodInterceptor 인터페이스를 구현해서 만든다.   


- InvocationHandler의 invoke() : 타깃 오브젝트에 대한 정보를 제공하지 않는다.   
타깃은 InvocationHandler를 구현할 클래스가 직접 알고있어야 한다.      

- MethodInterceptor의 invoke() : 타깃 오브젝트에 대한 정보까지 함께 제공받는다.   
덕분에 타깃 오브젝트에 상관없이 독립적으로 만들어질 수 있다.  
따라서 MethodInterceptor 오브젝트는 타깃이 다른 여러 프록시에서 함께 사용할 수 있고, 싱글톤 빈으로 등록이 가능하다.    

<br/>      

###### - 어드바이스 : 타깃이 필요 없는 순수한 부가기능    

InvocationHandler를 구현했을 떄와 달리 MethodInterceptor를 구현한 클래스에는     
타깃 오브젝트가 등장하지 않는다.   
MethodInterceptor로는 메소드 정보와 함께 타깃 오브젝트가 담긴 MethodInvocation 오브젝트가 전달된다.   


MethodInvocation은 타깃 오브젝트의 메소드를 실행할 수 있는 기능이 있기 때문에   
MethodInvocation는 부가기능을 제공하는 데만 집중할 수 있다.   

MethodInvocation은 일종의 콜백 오브젝트로 
proceed() 메소드를 실행하면 타깃 오브젝트의 메소드를 내부적으로 실행해주는 기능이 있다.         
그렇다면 MethodInvocation 구현 클래스는 일종의 공유 가능한 템플릿처럼 동작하는 것이다.       


ProxyFactoryBean은 작은 단위의 템플릿/콜백 구조를 응용해서 적용했기 때문에   
템플릿 역할을 하는 MethodInvocation을 싱글톤으로 두고 공유할 수 있다.   


ProxyFactoryBean에 이 MethodInterceptor를 설정해줄 때는 일반적인 DI 처럼   
수저장 메소드를 사용하는 대신 addAdvice()라는 메소드를 사용한다는 점도 눈여겨봐야 한다.    

add라는 이름에서 알 수 있듯이 ProxyFactoryBean에는 여러 MethodInterceptor를 추가할 수 있다.    
ProxyFactoryBean 하나만으로 여러 개의 부가기능을 제공해주는 프록시를 만들 수 있다는 뜻이다.    

MethodInterceptor처럼 타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트를  
스프링에서는 어드바이스(advice) 라고 부른다.    


ProxyFactoryBean은 인터페이스 타입을 제공받지 않고도 어떻게 프록시를 만들 수 있을까?    
ProxyFactoryBean에 있는 인터페이스 자동검출 기능을 사용해 타깃 오브젝트가 구현하고 있는 인터페이스 정보를 알아낸다.   
알아낸 인터페이스를 모두 구현하는 프록시를 만들어준다.    
일부만 프록시를 적용하고 싶다면 인터페이스 정보를 직접 제공해주면 된다.   

어드바이스는 타깃 오브젝트에 종속되지 않는 순수한 부가기능을 담은 오브젝트는 것을 잘 기억해두자.     

<br/>      


##### - 포인트컷 : 부가기능 적용 대상 메소드 선정 방법   


ProxyFactoryBean과 MethodInterceptor를 사용하는 방식에 메소드 선정 기능을 넣을 수 있을까?  
MethodInterceptor 오브젝트는 타깃 정보를 가지고 있지 않도록 만들어 여러 프록시가 공유할 수 있다.     
그래서 특정 프록시에만 적용되는 패턴을 넣으면 문제가 된다.     

ProxyFactoryBean을 사용하여,    
두 가지 확장 기능인 부가기능(Advice)와 메소드 선정 알고리즘(Pointcut)을 활용하는 유연한 구조로 만들자.   
어드바이스와 포인트컷은 모두 프록시에 DI로 주입되서 사용된다.   
두 가지 모두 여러 프록시에서 공유가 가능하도록 만들어지기 때문에 스프링의 싱글톤 빈으로 등록이 가능하다.   

포인트컷이 필요없을 때는 ProxyFactoryBean의 addAdvice() 메소드를 호출하여 어드바이스만 등록하고   
포인트컷이 필요할 때는 어드바이스와 포인트컷을 묶어 Advisor 타입으로 addAdvisor() 메소드를 호출해야 한다.   

ProxyFactoryBean에는 여러 개의 어드바이스와 포인트컷이 추가될 수 있기 때문에   
어떤 어드바이스가 어떤 포인트컷을 적용하는지 알려주기 위함이다.    

<br/>         


### 2. ProxyFactoryBean 적용     

ProxyFactoryBean은 스프링의 DI와 템플릿/콜백 패턴, 서비스 추상화 등의 기법이 모두 적용된 것이다.   
그 덕분에 독립적이고 여러 프록시가 공유할 수 있는 어드바이스와 포인트컷으로 확장 기능을 분리할 수 있었다.    

새로운 비즈니스 로직을 담은 서비스 클래스가 생성되어도 예제에서 만들어둔 TransactionAdvice를 그대로 재사용할 수 있다.   


<br/>      


# 스프링 AOP   

### 문제     

ProxyFactoryBean 과 Advisor를 이용하는 방식에   
target 속성을 다른 타겟으로 바꿔줘야 하기 때문에   
부가기능을 적용하려는 타겟이 바뀔 때마다 설정파일에서 비슷한 코드가 반복된다.  

<br/>      

### 해결   

##### 빈 후처리기    

빈 후처리기란, 빈 생성이 완료되고 난 뒤 후처리를 해주는 오브젝트이다.    
빈이 생성되고 난 뒤, 생성된 빈을 위임받아서 하고싶은 추가적인 처리를 해준다.    

생성된 빈을 후 처리기에서 프록시로 포장한다.    

<br/>      

##### DefaultAdvisorAutoProxyCreator      

어드바이저를 이용한 자동 프록시 생성기이다.   

빈 후처리기를 빈으로 등록하면 빈이 생성될 때마다 빈 후처리기에 보내 작업을 진행한다.    
빈 후처리기에서는 생성된 빈으로 어떤 것도 할 수 있어서   
이를 이용해 생성된 빈을 빈 후처리기에서 프록시로 포장할 수 있다.  



포인트 컷이 담긴 어드바이저를 빈으로 등록하고 빈 후처리기를 사용하면     
일일이 ProxyFactoryBean에 타겟만 변경해서 중복해서 등록하지 않아도 된다.       

그런데 후처리기를 사용하려면 포인트컷을 생성할 때 클래스 필터를 적용해야한다.      
모든 클래스에 전부 프록시를 적용할 수는 없기 때문이다.   
  
<br/>       


##### 전체적인 동작방식     

1. 빈 생성을 요청한다.   

2. 스프링 컨티에너에서 빈을 생성하면 빈 후처리기로 보낸다.     

3. 후처리기는 등록된 Advisor를 검색 포인트컷읉 통해     
프록시를 적용할 것인지 여부를 결정한다.      

4. 포인트컷 조건에 만족했으면 어드바이스를 적용한 프록시를 생성해서 리턴한다.          


<br/>       