---
layout: post
title: "자바 성능 튜닝 이야기 (2)"  
description: "story(6) - (8)"
date: 2020-06-07
tags: [java]
comments: true
share: true
---

## story 6. static 제대로 한번 써 보자          
자바 프로그래밍에서 성능을 향상시키는 방법 중 하나인 static 사용   
하지만 잘 모르고 static 을 사용하면 시스템이 더 느려지거나 오류 발생, JVM이 죽어버리는 상황도 발생할 수 있다.     

#### - static의 특징      

자바에서 static으로 지정했다면, 해당 메서드나 변수는 정적이다.   
  
  
```java  
public class VariableTypes {  
    static int classVariable;  
}  
```  


여기서 static으로 선언한 `classVariable`은 클래스 변수하고 한다.     
100개의 VariableTypes 클래스의 인스턴스를 생성하더라도, 모든 객체가 classVariablr에 대해서는 동일한 주소의 값을 참조한다.   

static의 특징은 다른 JVM에서는 static이라고 선언해도 다른 주소나 다른 값을 참조하지만,   
하나의 JVM이나 WAS 인스턴스에서는 같은 주소에 존재하는 값을 참조한다는 것이다.   
그리고 GC의 대상이 되지 않는다. 그러므로 static을 잘 사용하면 성능을 뛰어나게 향상시킬 수 있지만,   
특히 웹 환경에서 static을 잘못 사용하면 여러 스레드에서 하나의 변수에 접근할 수 있개 때문에 데이터가 꼬이는 일이 발생할 수도 있다.   


#### - static 잘 활용하기      

(1) 자주 사용하고 절대 변하지 않는 변수는 final static으로 선언하자.   
자주 변경되지 않고, 경우의 수가 단순한 쿼리 문장이 있다면 final static이나 static으로 선언하여 사용하자.   
간단한 데이터들도 static으로 선언할 수 있지만, 템플릿 성격으로 객체를 static으로 선언하는 것도 성능 향상에 많은 도움이 된다.   
Velocity를 사용할 때가 좋은 예이다.  


```java      
try {
    Template template = Velocity.getTemplate("TemplateFileName");
}   
```
   

템플릿 파일을 읽어서 파싱하기 때문에 서버의 CPU에 부하가 많이 발생하고 대기 시간도 많아진다.      
그러므로 수행하는 메서드에서 이 부분을 분리하여 다음과 같이 수행해야 한다.       


```java       
static Template template;   

static {        
    try {         
        template = Velocity.getTemplate("TemplateFileName");       
    }        
}      
``` 

클래스가 로딩될 때 한 번만 파싱하므로 성능이 엄청나게 향상된다.   
그런데 만약 해당 template 내용이 지속적으로 변경되는 부분이라면 이와 같이 코드를 작성할 경우   
A 화면이 보여야 하는 사용자에게 B 화면이 보일 수도 있기 때문에 상황에 맞게 적용하는 것이 중요하다.   


(2) 설정 파일 정보도 static으로 관리하자.   

클래스의 객체를 생성할 때마다 설정 파일을 로딩하면 엄청난 성능 저하가 발생하게 된다.   
이럴 때는 반드시 static으로 데이터를 읽어서 관리해야 한다.   


(3) 코드성 데이터는 DB에서 한 번만 읽자.          

부서가 적은 회사의 코드나, 건수가 그리 많지 않되 조회 빈도가 높은 코드성 데이터는 DB에서 한 번만 읽어서 관리하는 것이 성능 측면에서 좋다.   


#### - static과 메모리 릭     

static으로 선언한 부분은 GC가 되지 않는다.         
그럼 만약 어떤 클래스에 데이터를 Vector나 ArrayList에 담을 때 해당 Collection 객체를 static으로 선언하면 어떻게 될까?    
만약 지속적으로 해당 객체에 데이터가 쌓이는데 GC가 되지 않으면 시스템은 OutOfMemoryError를 발생시킨다.   
이렇게되면 시스템을 재시작해야 하고 해당 인스턴스는 더 이상 서비스할 수 없다.         


더 이상 사용 가능한 메모리가 없어지는 현상을 메모리 릭(Memory Leak)이라고 하는데, 
static과 Collection 객체를 잘못 사용하면 메모리 릭이 발생한다.        



## story 7. 클래스 정보, 어떻게 알아낼 수 있나?     
자바에는 클래스와 메서드의 정보를 확인할 수 있는 API가 있다.   

#### - reflection 관련 클래스들   

자바 API에는 reflection 이라는 패키지가 있다.    
이 패키지에 있는 클래스들을 사용하면 JVM에 로딩되어 있는 클래스와 메서드 정보를 읽어 올 수 있다.   

#### - Class 클래스    

Class 클래스는 클래스에 대한 정보를 얻을 때 사용하기 좋고, 생성자는 따로 없다.   
ClassLoader 클래스의 defineClass() 메서드를 이용해서 클래스 객체를 만들 수도 있지만, 좋은 방법은 아니다.     
그보다는 Object 클래스에 있는 getClass() 메서드를 사용하는 것이 일반적이다.     


#### - 정리   

reflection 관련 클래스를 사용하면 클래스의 정보 및 여러 가지 세부 정보를 알 수 있어 매우 편리하다.   
하지만 로그에서 사용하기 위해서라면, instanceof를 사용하는 것이 클래스의 이름으로 해당 객체의 타입을 비교하는 방법보다 낫다.       

추가적으로 클래스의 메타 데이터 정보는 JVM의 Perm 영역에 저장된다.            
만약 Class 클래스를 사용하여 엄청나게 많은 클래스를 동적으로 생산하는 일이 벌어지면          
Perm 영역이 더 이상 사용할 수 없게 되어 OutOfMemoryError가 발생할 수도 있어 조심해야 한다.        

## story 8. synchronized는 제대로 알고 써야 한다.   

**Q. 자바에서 스레드는 어떻게 사용하나?**       
  
#### - 프로세스와 스레드     

하나의 프로세스에는 한 개 ~ 여러 개의 스레드가 생성된다.   
그러므로 프로세스와 스레드의 관계는 일대다 관계라고 보면 된다.     
스레드는 다른 말로 Lightweight Process(LWP) 라고도 한다.   
즉, 가벼운 프로세스이고 프로세스에서 만들어 사용하고 있는 메모리를 공유한다.     
그래서 별개의 프로세스가 하나씩 뜨는 것보다는 성능이나 자우너 사용에 있어서 많은 도움이 된다.    

#### - Thread 클래스 상속과 Runnable 인터페이스 구현   

스레드의 구현은 Thread 클래스를 상속받는 방법과 Runnable 인터페이스를 구현하는 방법 두 가지가 있다.   
Thread 클래스는 Runnable 인터페이스를 구현한 것이기 때문에 어느 것을 사용해도 거의 차이가 없다.   
대신 Runnable 인터페이스 구현하면 원하는 기능을 추가할 수 있다. 하지만 해당 클래스를 수행할 때 별도의 스레드 객체를 생성해야 한다.   
또한, 자바는 다중 상속을 인정하지 않기 때문에 스레드를 사용해야 할 때 이미 상속받은 클래스가 존재한다면 Runnable 인터페이스를 구현해야 한다.   

Runnable 인터페이스를 구현한 경우,   
Thread 클래스의 Runnable 인터페이스를 매개변수로 받는 생성자를 사용해서 Thread 클래스를 만든 후 start() 메서드를 호출해야 한다.   
그렇지 않고 그냥 run() 메서드를 호출하면 새로운 스레드가 생성되지 않는다.    
       
```java     
RunnableImpl ri = new RunnableImpl();  
ThreadExtends te = new ThreadExtends();  

new Thread(ri).start();  
te.start();   
```   

#### - sleep(), wait(), join() 메서드   

현재 진행 중인 스레드를 대기하도록 하기 위해서는 sleep(), wait(), join() 세 가지 메서드를 사용하는 방법이 있다.   
   
(1) wait() : 모든 클래스의 부모 클래스인 Object 클래스에 선언되어 있어서 어떤 클래스에서도 사용할 수 있다.     
   
(2) sleep() : 명시된 시간만큼 해당 스레드를 대기시킨다. 매개변수를 지정해서 사용한다.     

아래 두 메서드는 static 메서드이기 떄문에 반드시 스레드 객체를 통하지 않아도 사용할 수 있다.           
- sleep(long millis) 
- sleep(long millis, int nanos)     

(3) join() : 명시된 시간만큼 해당 스레드가 죽기를 기다린다. 만약 아무런 매개변수를 지정하지 않으면 죽을 때까지 계속 대기한다.   

wait() 메서드도 명시된 시간만큼 해당 스레드를 대기시킬 수 있는데 sleep() 메서드와 다른 점은 매개변수이다.   
만약 아무런 매개변수를 지정하지 않으면 notify() 메서드 혹은 notifyAll() 메서드가 호풀될 때까지 대기한다.   
wait() 메서드가 대기하는 시간 설정 방법은 sleep() 메서드와 동일하다.       

이 세 가지 메서드는 모두 예외를 던지도록 되어 있어 사용할 때 반드시 예외 처리를 해주어야 한다.     


#### - interrupt(), notify(), notifyAll() 메서드    

앞서 명시한 세 개의 메서드를 '모두' 멈출 수 있는 유일한 메서드는 interrupt() 메서드다.   
interrupt() 메서드가 호출되면 중지된 스레드에는 InterruptedException이 발생한다.    
제대로 수행되었는지 확인하려면 interrupted() 메서드(스레드의 상태를 변경시킴)를 호출하거나    
isInterrupted() 메서드(스레드의 상태만을 리턴함)를 호출하면 된다.      

notify() 메서드와 notifyAll() 메서드는 모두 wait() 메서드를 멈추기 위한 메서드다.   
이 두 메서드는 Object 클래스에 정의되어 있는데, wait() 메서드가 호출된 후 대기 상태로 바뀐 스레드를 꺠운다.   
notify() 메서드는 객체의 모니터와 관련있는 단일 스레드를 깨우며, notifyAll() 메서드는 객체의 모니터와 관련 있는 모든 메서드를 깨운다.   


#### - interrupt() 메서드는 절대적인 것이 아니다.
   
interrupt() 메서드를 호출하여 특정 메서드를 중지시키려고 할 때 항상 해당 메서드가 멈출까?    
답은 아니다. interrupt() 메서드는 해당 스레드가 'block' 되거나 특정 상태에서만 작동한다.   

interrupt() 메서드는 대기 상태일 때에만 해당 스레드를 중단시키기 때문에   
while(true)와 같은 코드에서는 멈추지 않는다.    
이와 같은 반복 구문을 안전하게 만들려면 안전장치를 추가하는 것이 좋다.   
여러 방법이 있는데 flag 값을 수정하거나 sleep()을 추가하는 방법을 알아보자.   

(1) flag 값 수정하기    
 
```java   
public void setFlag(boolean flag) {  
    this.flag = flag;    
}    
```  

다른 스레드에서 interrupt() 메서드를 호출한 후 flag를 변경하면 된다. (main() 메서드 가장 마지막 줄)      

(2) sleep() 추가하기     

```java  
try {
    Thread.sleep(0, 1);
} catch(Exception e) {
    break;
}
```

#### - Synchronized를 이해하자.  
 
synchronized는 메서드와 블록으로 사용할 수 있다.   
절대로 생성자의 식별자로는 사용할 수 없다.   

```java  
public synchronized void sampleMethod() {
    // 생략
}

private Object obj = new Object();
public void sampleBlock() {
    synchronized(obj) {
        // 생략
    }
}
```

간단하게 synchronized라는 식별자로 동기화할 수 있다.   
그럼 언제 동기화를 사용해야 할까?   

(1) 하나의 객체를 여러 스레드에서 동시에 사용할 경우      
(2) static으로 선언한 객체를 여러 스레드에서 동시에 사용할 경우      

위의 경우가 아니면 동기화를 할 필요가 없다.      


#### - 동기화는 이렇게 사용한다. - 동일 객체 접근 시   

예를들어, 여러 기부자가 어떤 기부금을 처리하는 단체에 기부금을 낸다고 가정하자.      
총 기부금 : amount      

(1) 각각 단체에 시부 동기화 미사용 : 1.3 ms             
(2) 동일 단체에 기부 동기화 미사용 : 정상적인 결과 값이 넘어오지 않는다.          
(3) 동일 단체에 기부 동기화 사용 : 10.1ms             

만약 1번 케이스에 synchronized를 사용하면 어떻게 될까?   
이 경우에는 2.2ms 가 소요된다.   
필요없는 부분에 synchronized를 사용하면 약간이지만 성능에 영향을 준다는 의미이다.     

반드시 필요한 부분에만 동기화를 사용해야 성능 저하를 줄일 수 있다.   


#### - 동기화는 이렇게 사용한다. - static 사용 시    

static을 사용하는 경우에 동기화를 사용한다.          
앞서 살펴본 예제에서 amount를 static으로 선언하고 synchronized를 사용하면 어떻게 될까?          

우선 amount를 static으로 선언하면 여러 단체가 있더라도 (객체의 변수가 아닌 클래스의 변수가 된다.)      
하나의 amount에 값을 지정하게 되므로 각 단체에 따로 기부하는 것은 구현할 수 없다.              

그럼 donate() 메서드에 synchronized를 추가하면 될까?    
아니다. 우리가 원하는 결과 값이 나오지 않는다.   
synchronized는 각각의 객체에 대한 동기화를 하는 것이기 때문에 이렇게 하면 각각의 단체에 대한 동기화는 되지만   
amount에 대한 동기화는 되지 않는다.     

amount는 클래스 변수이기 때문에 메서드도 클래스 메서드로 참조하도록 static을 추가해 주어야 한다.   
    
```java               
public static synchronized void donate() {           
    amount++;        
}       
```        

이렇게 구현하면 원하는 결과 값을 얻을 수는 있다.   
하지만 항상 변하는 값에 대해서 static으로 선언하는 것은 위험하다.   
synchronized도 꼭 필요할 때만 사용하는 것이 좋다.    


### - 동기화를 위해서 자바에서 제공하는 것들

JDK 5.0부터 추가된 java.util.concurrent 패키지에 대해서 간단히 알아보자.     
이 패키지에 주요 개념 4가지가 포함되어 있다.   

(1) Lock : 실행 중인 스레드를 간단한 방법으로 정지시켰다가 실행시킨다. 상호참조로 인해 발생하는 데드락을 피할 수 있다.     

(2) Execute : 스레드를 더 효율적으로 관리할 수 있는 클래스들을 제공한다.   

(3) Concurrent 콜렉션 : 앞서 살펴본 콜렉션의 클래스들을 제공한다.   

(4) Atomic 변수 : 동기화가 되어 있는 변수를 제공한다. 이 변수를 사용하면, synchronized 식별자를 메서드에 지정할 필요가 없이 사용할 수 있다.   


