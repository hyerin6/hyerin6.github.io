---
layout: post
title: "자바 성능 튜닝 이야기 (3)"  
description: "story(10) - (16)"
date: 2020-06-07
tags: [java]
comments: true
share: true
---

## story 10. 로그는 반드시 필요한 내용만 찍자.    

어떤 로거를 사용하든 모두 성능상 이슈가 발생할 수 있다.   

#### - System.out.println() 의 문제점   

System.out.println() 메서드를 사용한 시스템 로그는       
편하지만 성능에 영향을 많이 주는 경우가 빈번히 발생한다.   

파일이나 콘솔에 로그를 남길 경우를 생각해보자. 내용이 완전히 프린트되거나 저장될 때까지,   
뒤에 프린트하려는 부분은 대기할 수 밖에 없다.   
특히 콘솔에 로그를 남길 경우에는 더더욱 그렇다.   
그렇게 되면 애플리케이션에서는 대기 시간이 발생한다.   

이 대기 시간은 시스템의 속도에 의존적이다.   
만약 디스크에 로그를 남긴다면, 서버 디스트의 RPM이 높을수록 로그의 처리 속도는 빨라질 것이다.   


## story 11. JSP와 서블릿, Spring에서 발생할 수 있는 여러 문제점     

#### - JSP와 Servlet의 기본적인 동작 원리는 꼭 알아야 한다.   

일반적으로 JSP와 같은 웹 화면단을 처리하는 부분에서 소요되는 시간은 많지 않다.     
JSP의 경우 가장 처음에 호출되는 경우에만 시간이 소요되고, 그 이후의 시간에는 컴파일된 서블릿 클래스가 수행되기 때문이다.     
그럼 JSP의 라이프 사이클을 간단하게 리뷰해보자.    

1. JSP URL 호출   
2. 페이지 번역   
3. JSP 페이지 컴파일   
4. 클래스 로드   
5. 인스턴스 생성   
6. jspInit 메서드 호출   
7. _jspService 메서드 호출   
8. jspDestory 메서드 호출   

여기서 해당 JSP 페이지가 이미 컴파일되어 있고, 클래스가 로드되어 있고, JSP 파일이 변경되지 않았다면,     
가장 많은 시간이 소요되는 2 ~ 4 프로세스는 생략된다.   

이번에는 서블릿의 라이프 사이클을 살펴보자.   

- Servlet 객체가 자동으로 생성되고 초기화 되거나,     
- 사용자가 해당 Servlet을 처음으로 호출했을 때 생성되고 초기화 된다.     

그 다음에는 계속 '사용 가능' 상태로 대기한다.         


**서블릿은 JVM에 여러 객체로 생성되지 않는다.** 는 점을 기억해야 한다.   

다시 말해서 WAS가 시작하고, '사용 가능' 상태가 된 이상 대부분의 서블릿은 JVM에 살아 있고,    
여러 스레드에서 해당 서블릿의 service() 메서드를 호출하여 공유한다.      



#### - 자바 빈즈, 잘 쓰면 약 못 쓰면 독  
  
자바 빈즈(Java Beans)는 UI에서 서버 측 데이터를 담아서 처리하기 위한 컴포넌트이다.      
간단하게 자바 빈즈의 문제점을 알아보자.   

자바 빈즈를 통해 useBean을 하면 성능에 많은 영향을 미치지는 않지만, 너무 많이 사용하면 JSP에서 소요되는 시간이 증가될 수 있다.   

한두 개의 자바 빈즈를 사용하는 것은 상관 없지만, 10~20개의 자바 빈즈를 사용하면 성능에 영향을 주게 된다.   
그래서 TO를 만들어서 사용하도록 하자.   


#### - 스프링 프레임워크 간단 정리   

스프링 프레임워크는 데스크톱과 웹 어플리케이션, 작고 간단한 애플리케이션부터            
여러 서버와 연동하여 동작해야 하는 엔터프라이즈 애플리케이션도 범용적인 애플리케이션 프레임워크이다.           

Spring의 가장 큰 특징은 복잡한 애플리케이션도 POJO(Plain Old Java Object)로 개발할 수 있다는 점이다.   
서블릿을 개발하려면 반드시 HttpServlet이라는 클래스를 상속해야 한다.   
하지만 스프링을 사용하면 HttpServlet을 확장하지 않아도 웹 요청을 처리할 수 있는 클래스를 만들 수 있다.   


#### - 스프링의 핵심 기술   

Dependency Injection, Aspect Oriented Programming, Portable Service Abstraction 으로 함축할 수 있다.    

(1) Dependency Injection     
'의존성 주입' 이라고 한다.    
객체간의 관계를 관리하는 기술로 생각하면 된다.     
어떤 객체가 필요로 하는 객체를 자기 자신이 직접 생성하여 사용하는 것이 아니라    
외부에 있는 다른 무언가로부터 필요로 하는 객체를 주입 받는 기술이다.        

(2) AOP (Aspect Oriented Programming)    
'관점 지향 프로그래밍' 이라고 부른다.   
대부분은 비슷한 코드가 중복되고 코드를 읽는 데 방해가 된다.   
이런 코드를 실제 비즈니스 로직과 분리할 수 있도록 도와주는 것이 바로 AOP이다.   

자바에서 가장 유명한 AOP 프레임워크로는 AspectJ가 있다.   

(3) PSA (Portable Service Abstraction)    
스프링은 비슷한 기술을 모두 아우를 수 있는 추상화 계층을 제공하여, 사용하는 기술이 바뀌더라도   
비즈니스 로직의 변화가 없도록 도와준다.   


#### - 스프링 프레임워크를 사용하면서 발생할 수 있는 문제점들     

스프링 프레임워크를 사용할 때 성능 문제가 가장 많이 발생하는 부분은 '프록시(proxy)'와 관련이 있다.   
스프링 프록시는 기본적으로 실행 시에 생성된다.   
따라서 요청량이 많은 운영 상황으로 넘어가면 문제가 나타날 수 있다.   

스프링이 프록시를 사용하게 하는 주요 기능은 트랜잭션이다.   
`@Transaction` 어노테이션을 사용하면 해당 어노테이션을 사용한 클래스의 인스턴스를 처음 만들 때 프록시 객체를 만든다.   
개발자가 직접 스프링 AOP를 사용해서 별도의 기능을 추가하는 경우에도 프록시를 사용하는데,   
이 부분에서 문제가 많이 발생한다.   

따라서, 간단한 부하 툴을 사용해서라도 성능적인 면을 테스트해야만 한다.   

추가로, 스프링이 내부 매커니즘에서 사용하는 캐시도 조심해야 한다.   
예를들어 스프링 MVC에서 작성하는 메서드의 리턴 타입으로 다음과 같은 문자열을 사용할 수 있다.   
이 때 매번 동일한 문자열에 대한 뷰 객체를 새로 찾기 보다는 이미 찾아본 뷰 객체를 캐싱해두면      
다음에도 동일한 문자열이 반환됐을 때 훨씬 빠르게 뷰 객체를 찾을 수 있다.     

스프링이 제공하는 ViewResolver 중에 자주 사용되는 InternalResourceViewResolver에는 그러한 캐싱 기능이 내장되어 있다.   
(ViewResolver는 뷰 이름과 지역화를 위한 Locale을 파라미터로 전달받으며,        
매핑되는 View 객체를 리턴한다. 만약, 매핑되는 View 객체가 존재하지 않으면 null을 리턴한다.)              


만약 매번 다른 문자열이 생성될 가능성이 높고, 상당히 많은 수의 키 값으로 캐싱 값이 생성될 여지가 있는 상황에서는   
문자열을 반환하는 게 메모리에 치명적일 수 있다.   

이런 상황에서는 뷰 이름을 문자열로 변환하기보다는 뷰 객체 자체를 반환하는 방법이 메모리 릭을 방지하는 데 도움이 된다.   
        
```java       
@GetMapping("/members/{id}")
public View hello(@PathVariable int id) {
    return new RedirectView("/members/" + id);
}    
```     



## story 12. DB를 사용하면서 발생 가능한 문제점들     

자바 기반 애플리케이션의 성능을 진단해 보면, 응답 속도를 지연시키는 대부분의 요인은 DB 쿼리 수행 시간과 결과를 처리하는 시간이다.   

이 책의 저자는 애플리케이션에서의 DB 접속 관련 공지가 있었다고 한다.     
주된 내용은 다음과 같다.   

- DB Connection을 할 경우에는 반드시 공통 유틸리티를 사용할 것.   

- 각 모듈별 DataSource를 사용하여 리소스가 부족한 현상이 발생하지 않아도록 할 것. 
  
- 반드시 Connection, Statement 관련 객체, ResultSet을 close할 것.  
 
- 페이지 처리를 하기 위해서 ResultSet객체.last() 메서드를 사용하지 말 것.     

왜 위와 같은 조치를 취해야 하는지 알아보자.   


#### - DB Connection 과 Connection Pool, DataSource    
   
일반적으로 DB에 연결하여 사용하는 방법에서 가장 느린 부분은 Connection 객체를 얻는 부분이다.   
DB와 WAS 사이에는 통신을 해야 하기 때문이다.   
사용자가 갑자기 증가하면 Connection 객체를 얻기 위한 시간이 엄청나게 소요될 것이며, 많은 화면이 예외를 발생시킬 것이다.   

이러한 부담을 줄이기 위해 사용하는 것이 DB Connection Pool이다.   


가능하면 안정되고 검증된 WAS에서 제공하는 DB Connection Pool이나 DataSource를 사용하자.   


Statement와 거의 동일하게 사용할 수 있는 Statement 인터페이스의 자식 클래스로 PreparedStatement가 있다.   
그리고 PL/SQL을 처리하기 위해서 사용하는 PreparedStatement의 자식 클래스로 CallableStatement가 있다.   


**Statement VS. PreparedStatement**  
이 둘의 가장 큰 차이점은 캐시(cache) 사용 여부이다.   
이 둘을 사용할 때는 다음과 같은 프로세스를 거친다.   
 
1. 쿼리 문장 분석     
2. 컴파일      
3. 실행        


Statement를 사용하면 매번 쿼리를 수행할 때마다 1~3 단계를 거치고   
PreparedStatement는 처음 한 번만 세 단계를 거친 후 캐시에 담아서 재사용 한다는 것이다.   

만약 같은 쿼리를 반복적으로 수행한다면 PreparedStatement가 DB에 훨씬 적은 부하를 주며, 성능도 좋다.      


#### - DB를 사용할 때 닫아야 하는 것들    
일반적으로 각 객체를 얻는 순서는 Connection, Statement, ResultSet 순이며,    
객체를 닫는 순서는 ResultSet, Statement, Connection 순이다.     

먼저 ResultSet 객체가 닫히는 경우는 다음과 같다.    

- close() 메서드 호출   
- GC의 대상이 되어 GC되는 경우   
- 관련된 Statement 객체의 close() 메서드가 호출되는 경우   

그렇다면 왜 굳이 close() 를 해야 하는가?      

Connection, Statement 관련 인터페이스, ResultSet 인터페이스에서 close() 메서드를 호출하는 이유는   
자동으로 호출되기 전에 관련된 DB와 JDBC 리소스를 해제하기 위함이다.   

Statement 객체는 Connection 객체를 close() 한다고 자동으로 닫히지 않는다.   
다음 두 경우에만 닫히므로, 반드시 close() 메서드를 호출해야 한다.   

- close() 메서드 호출      
- GC의 대상이 되어 GC되는 경우      

가장 문제가 되는 Connection 인터페이스의 객체에 대해 알아보자.    
다음 세 가지 경우에 닫힌다.   

- close() 메서드 호출        
- GC의 대상이 되어 GC되는 경우      
- 치명적인 에러가 발생하는 경우        


더 이상 사용할 수 있는 연결이 없으면, 여유가 생길 때까지 대기한다.   
그러다가 어느 정도 시간이 지나면 오류가 발생한다.   

GC가 될 때까지 기다리면 Connection Pool이 부족해지는 것은 시간 문제다.   

아래와 같은 방법으로 이를 해결할 수 있다.   

```java
try {

    . . .

} catch(Exception e) {

    . . .

} finally {
    try{rs.close();}catch(Exception rse){}
    try{ps.close();}catch(Exception pse){}
    try{con.close();}catch(Exception cone){}
}
```
위 예는 throws 예외 구문이 있다는 가정 하에 작성되었다.   

무엇보다도 가장 좋은 방법은 DB와 관련된 처리를 담당하는 관리 클래스를 만드는 것이다.   
보통 DBManager 이라는 이름의 클래스를 많이 사용한다.    


#### - JDK 7 에서 등장한 AutoClosable 인터페이스 

JDK 7부터 등장한 java.lang 패키지에 AutoClosable이라는 인터페이스가 있다.   

AutoClosable 인터페이스에는 리턴 타입이 void인 close() 메서드 단 한 개만 선언되어 있다.   
close() 메서드의 설명은 다음과 같다.   

- try-with-resources 문장으로 관리되는 객체에 대해서 자동적으로 close() 처리를 한다.   
- InterruptedException을 던지지 않도록 하는 것을 권장한다.   
- 이 close() 메서드를 두 번 이상 호출할 경우 뭔가 눈에 보이는 부작용이 나타나도록 해야 한다.   

가장 중요한 것은 `try-with-resources` 이다.   
try 블록이 시작될 때 소괄호 안에 close() 메서드를 호출하는 객체를 생성해 주면   
별도로 finally 블록에서 close() 메서드를 호출할 필요가 없어졌다는 의미다.   


#### - ResultSet.last() 메서드   

이 메서드는 "ResultSet 객체가 갖고 있는 결과의 커서(Corsor)를 맨 끝으로 옮겨라" 라는 지시를 하는 메서드이다.   
rs.next()가 다음 커서로 옮기는 것과 비교하면 이해하기가 쉬울 것이다.   
이 메서드를 수행하는 이유가 뭘까?       
대부분의 이유는 다음과 같이 사용하기 위해서이다.   


```java    
rs.last();  
int totalCount = rs.getRow();  
ResultArray[] result = new ResultArray[totalCount];  
```  

전체 데이터 개수를 확인하고 배열에 담아서 사용하기 위해서라면 양호한 편..       
배열을 Vector로 변경하고 사용하면 되기 때문이다.        
하지만 게시판과 같은 화면을 구성할 때 전체 수를 확인하기 위해서라면      
select count(*) from ... 과 같은 쿼리를 한 번 더 던져서 확인하는 것이 훨씬 빠르다.   


그럼 rs.last() 에는 문제가 있을까?    
rs.last() 메서드의 수행 시간은 데이터의 건수 및 DB와의 통신 속도에 따라서 달라진다.   
건수가 많으면 많을 수록 대기 시간이 증가하기 때문에 rs.next()를 수행할 때와 비교할 수 없을 정도로 속도 차이가 나기 때문에,   
이 메서드의 사용은 자제해야 한다.   



## story 13. XML과 JSON도 잘 쓰자.    

#### - JSON과 파서들   

JSON 데이터는 다음과 같은 두 가지의 구조를 기본으로 하고 있다.    

- name/value 형태의 쌍으로 collection 타입   
- 값의 순서가 있는 목록 타입   

JSON도 많은 CPU와 메모리를 점유하며 응답 시간도 느리다.       

많은 종류의 자바 기반 JSON 파서들이 존재하는데, 가장 많이 사용되는 JSON 파서로는 Jackson JSON과 google-gson 등이 있다.   


Jackson JSON 에 대해 알아보자.   

JSON을 파싱하는 코드의 성능 비교 결과를 보면 XML 파싱이 JSON 보다 매우 느리다고 생각할 수 있지만,  
데이터를 전송하기 위해서 XML 및 JSON 데이터를 Serialize와 Deserialize 할 경우도 있다.     


그런데 JSON 데이터는 Serialize와 Deserialize를 처리하는 성능이 좋지 않다.   
XML 파서보다 JSON 파서가 느린 경우가 대부분이다.   

(JSON 데이터를 자바로 파싱하는 라이브러리들의 성능을 비교하는 여러 글을 읽어봤는데 대용량 환경에서는 Jackson을         
마이크로 서비스와 분산아키텍처 설정등과 같이 작은 용량의 많은 json 파일을 처리하는 환경이라면 GSON을 사용하는 것이 좋다는 결론이 많았다.)      



#### - 정리하며   
XML 이나 JSON을 데이터 처리 기준으로 선정한다면, 메모리 및 CPU 사용량 손실을 반드시 염두에 둬야한다.   



## story 14. 서버를 어떻게 세팅해야 할까?    

#### - 설정해야 하는 대상   

개발하는 것만큼 중요한 것이 서버의 세팅이다. 개발된 프로그램이 0.1초 걸린다고 해도 서버 세팅을 잘못하면 1초가 걸릴 수도 있다.            
이러한 문제를 진단하는 가장 좋은 방법은 성능 테스트를 통해서 병목 지점을 미리 파악하는 것이다.         

무조건 애플리케이션 위주로 병목을 찾는 것보다, 일단 문제가 될만한 세팅 값을 먼저 진단하는 것이 가장 효율적이다.         
웹 기반의 시스템에서 성능에 영향을 줄만한 세팅을 나열해 보면 다음과 같다.         

- 웹 서버 세팅   
- WAS 서버 세팅   
- DB 서버 세팅   
- 장비 세팅    


#### - 아파치 웹 서버의 설정    

웹 서버는 반드기 WAS 앞에 두어야 한다.   
웹에서 사용하는 어플리케이션 서버이지 웹 서버가 아니다. 정적인 부분은 웹 서버에서 처리해야 한다.      


#### - 웹 서버의 Keep Alive    
웹 서버와 웹 브라우저가 연결이 되었을 때 KeepAlive 기능이 켜져 있지 않으면, 매번 HTTP 연결을 맺었다 끊었다 하는 작업을 반복한다.   

KeepAlive 기능이 켜져 있음녀 두 개 정도의 연결을 열어서 끊지 않고, 연결을 계속 재사용한다.   


[참고] 정적인 파일들은 일반적이 웹 서버에서 처리하지 않고 CDN 서비스 사용하는 경우도 있는데...     
이는 동적인 컨텐츠들을 WAS 에서 처리하도록해서 Web-WAS 서버의 부담을 줄여준다.         
(비용이 비싸다는 단점이 있음)       

KeepAlive 설정을 할 때 반드시 같이 해야 하는 설정이 있다.   
KeepAlive-Timeout 설정이다.          
마지막 연결이 끝난 이후에 다음 연결이 될 때까지 얼마나 기다릴지를 설정한다.   

하지만 무조건 KeepAlive 옵션을 켜야 성능이 좋게 나오는 것은 아니다. 상황에 맞게 사용해야 한다.   


#### - DB Connection Pool 및 스레드 개수 설정       

DB Connection Pool 과 스레드 개수에 대해서 알아보자.    
이 두 항목의 개수는 메모리와 관련이 있다.      

많이 사용할수록 메모리를 많이 점유하게 된다.     
그렇다고 메모리를 위해서 DB Connection Pool 과 스레드 개수를 적게 지정하면,       
서버에서는 많은 요청을 처리하지 못하고 대기할 수밖에 없다.        


대부분의 WAS에서 DB Connection Pool의 개수를 최소치, 증가치, 최대치 등으로 지정할 수 있다.     
최소치는 서버가 기동될 때 연결을 수행하는 개수이다.       
최소 개수가 많으면 많을수록 서버 기동하는 시간이 오래 소요된다.   

운영 중에는 최소 및 최대 값을 동일하게 하는 것이 좋다.   

대부분 DB Connection Pool 보다 스레드 개수를 10개 정도 더 지정하는데,   
이유는 스레드 개수가 DB Connection Pool 의 개수보다 적으면 적은 수만큼의 연결은 필요 없기 때문이다.   

쉽게 스레드는 입구이고 DB Connection Pool은 출구라고 생각하면 된다.   


## story 16. JVM은 어떻게 구동될까?    

웹 기반 시스템을 배포할 때 그냥 재시작만 한다면,         
배포 직후 시스템 사용자들은 엄청나게 느린 응답 시간과 함께 시스템에 대한 많은 불만을 갖게 될 수도 있다.         
즉, warning up이 필요한데 왜 이런 작업이 필요할까?    
왜 WAS을 재시작하면 성능이 느린지 알아보자.   

반드시 성능과 관련있는 부분은 아니지만 아래 내용은 알아두면 좋다. 
  
- HotSpot VM 구조   
- JIT 옵티마이저   
- JVM의 구동 절차   
- JVM의 종료 절차   
- 클래스 로딩의 절차   
- 예외 처리의 절차             


#### - HotSpot VM 은 어떻게 구성되어 있을까?    

자바를 만든 Sun에서 자바의 성능을 개선하기 위해 Just In Time(JIT) 컴파일러를 만들었고,   
이름을 HotSpot이라고 지었다.      

JIT 컴파일러는 프로그램의 성능에 영향을 주는 지점에 대해서 지속적으로 분석한다.    
분석된 지점은 부하를 최소화하고, 높은 성능을 내기 위한 최적화의 대상이 된다.   

HotSpot VM은 세 가지 주요 컴포넌트로 되어 있다.  

- VM(Virtual Machine) 런타임   
- JIT 컴파일러   
- 메모리 관리자   

HotSpot VM은 높은 성능과 확장성을 제공한다.       
일례로 JIT 컴파일러는 자바 애플이케이션이 수행되는 상황을 보고 동적으로 최저고하를 수행한다.        


#### - JIT Optimizer라는 게 도대체 뭘까?     
HotSpot VM JIT 컴파일러에 대해서 이야기하지 전에   
Client 버전과 Server 버전으로 나뉜다는 것을 기억하자.      

client는 스타트업 시간과 메모리공간에 대한 최적화에 중점을 두고 있고,      
server는 시작시간은 좀 걸리더라도 다수의 request를 빠르게 처리하는데에 중점을 맞추고 있다.      


































