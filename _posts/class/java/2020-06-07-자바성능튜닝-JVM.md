---
layout: post
title: "JVM은 어떻게 구동될까?"  
description: "자바 성능 튜닝 이야기 story 16"
date: 2020-06-07
tags: [java]
categories: [Java]
comments: true
share: true
published: true
---

<br />    

웹 기반 시스템을 배포할 때 그냥 재시작만 한다면,         
배포 직후 시스템 사용자들은 엄청나게 느린 응답 시간과 함께 시스템에 대한 많은 불만을 갖게 될 수도 있다.         
즉, warning up이 필요한데 왜 이런 작업이 필요할까?    
왜 WAS을 재시작하면 성능이 느린지 알아보자.

반드시 성능과 관련있는 부분은 아니지만 아래 내용은 알아두면 좋다.

- HotSpot VM 구조
- JIT 옵티마이저
- JVM의 구동 절차
- JVM의 종료 절차
- 클래스 로딩의 절차
- 예외 처리의 절차

<br/>         

## HotSpot VM 은 어떻게 구성되어 있을까?

자바를 만든 Sun에서 자바의 성능을 개선하기 위해 Just In Time(JIT) 컴파일러를 만들었고,   
이름을 HotSpot이라고 지었다.

JIT 컴파일러는 프로그램의 성능에 영향을 주는 지점에 대해서 지속적으로 분석한다.    
분석된 지점은 부하를 최소화하고, 높은 성능을 내기 위한 최적화의 대상이 된다.

HotSpot VM은 세 가지 주요 컴포넌트로 되어 있다.

- VM(Virtual Machine) 런타임
- JIT 컴파일러
- 메모리 관리자

HotSpot VM은 높은 성능과 확장성을 제공한다.       
일례로 JIT 컴파일러는 자바 애플이케이션이 수행되는 상황을 보고 동적으로 최저고하를 수행한다.

<br/>         

## JIT Optimizer라는 게 도대체 뭘까?
HotSpot VM JIT 컴파일러에 대해서 이야기하기 전에   
Client 버전과 Server 버전으로 나뉜다는 것을 기억하자.

client는 스타트업 시간과 메모리공간에 대한 최적화에 중점을 두고 있고,      
server는 시작시간은 좀 걸리더라도 다수의 request를 빠르게 처리하는데에 중점을 맞추고 있다.



자바는 jacac라는 컴파일러를 사용한다, 이 컴파일러는 소스코드를 바이트 코드로 된 class라는 파일로 변환해준다.    
그래서 JVM은 항상 바이트 코드로 시작하며, 동적으로 기게에 의존적인 코드로 변환한다.

JIT은 애플리케이션에서 각각의 메서드를 컴파일할 만큼 시가적 여유가 많지 않다.     
그러므로, 모든 코드는 초기에 인터프리터에 의해서 시작되고 해당 코드가 충분히 많이 사용될 경우에 컴파일할 대상이 된다.

HotSpot VM에서 이 작업은 각 메서드에 있는 카운터를 통해서 통제되며, 메서드에는 두 개의 카운터가 존재한다.

- 수행 카운터 : 메서드를 시작할 때마다 증가.
- 백에지 카운터 : 높은 바이트 코드 인덱스에서 낮은 인텍스로 컨트롤 흐름이 변경될 때마다 증가

여기서 백에지 카운터는 메서드가 루프에 존재하는지를 확인할 때 사용되며 수행 카운터 보다 컴파일 우선 순위가 높다.

이 카운터들이 인터프리터에 의해 증가될 때마다 그 값들이 한계치에 도달했는지 확인하고   
도달했을 경우 인터프리터는 컴파일을 요청한다.

<br/>         

## JRockit의 JIT 컴파일 및 최적화 절차

- JRockit runs JIT compilation

자바 애플리케이션을 실행하면 기본적으로 1번 단계인 JIT 컴파일을 거치고 수행된다.      
이 단계를 거친 후 메서드가 수행되면 그 다음부터는 컴파일된 코드를 수행하기 때문에 처리 성능이 빨라진다.      
JIT을 사용하면 시작할 때의 성능은 느리겠지만, 지속적으로 수행할 때는 더 빠른 처리가 가능하다.


- JRockit monitors threads

JRockit에는 'sampler thread' 라는 스레드가 존재한다.   
주기적으로 어떤 스레드가 동작 중인지, 수행 내역을 관리하여 최적화 대상을 찾는다.


- JRockit JVM Runs Optimization

'sampler thread'가 식별한 대상을 최적화한다.       
백그라운드에서 진행되서 수행중인 애플리케이션에 영향을 주지 않는다.


<br/>         

JVM에 대한 더 많은 내용을 다음 글을 참고하면 좋을 것이다.   

[JVM 에 대한 Naver D2 글](https://d2.naver.com/helloworld/1230)    

<br/>           
