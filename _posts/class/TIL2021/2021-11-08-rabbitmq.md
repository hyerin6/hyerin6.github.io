---  
layout: post    
title: "Message Queue란?"     
description: "RabbitMQ 실습"     
date: 2021-11-08  
tags: [CQRS, MQ]  
comments: true    
share: true
---    

<br />

## 톰캣은 사용자의 요청을 어떻게 처리할까?
사용자의 요청은 우선 큐에 들어가고 큐에 들어간 요청이 늘고있는 스레드가 있다면 

그 스레드에 할당되어 처리된다. 

톰캣 기본 설정은 큐 사이즈는 100, 스레드 사이즈는 200이다. 

모든 스레드가 사용 중이면 새로운 요청이 들어왔을 때 그 요청은 큐에서 대기하는 것이다. 

<br />

큐 사이즈를 모두 채우고 나서도 계속 요청이 들어오면 그 요청들은 버려진다. 

큐에 들어온 요청도 30초가 지나면 타임아웃 처리된다. (기본설정이 30초)

<br />

물론 이 기본 설정들을 변경할 수 있지만 결과적으로 해결 방법이 되는 것은 아니다. 

실제 처리 속도를 올리지 않으면 결국 요청이 큐에 쌓일 것이다. 

<br />
<br />

## Message Queue

이전 게시글에서 CQRS 구현 방법에 대해 알아보면서 메시징 수단을 이용해 DB에 반영할 데이터를 전달할 수 있다고 했다.   

여기서 메시징 수단이 바로 Message Queue이다.    


* Producer: 메시지를 큐에 전송   
* Consumer: 큐의 메시지를 처리하는 방식   

MQ 사용 목적은 비동기로 요청을 처리하고 큐에 저장하여 Consumer의 명목을 줄이는 것에 있다. 


<br />
<br />


## RabbitMQ 

RabbitMQ는 AMQP(Advanced Message Queueing Protocol)을 구현한 오픈소스 메세지 브로커(중개자)이다.

Rabbit MQ는 데이터를 일단 어딘가에 쌓아두고 나중에 비동기적으로 적절한 처리를 하고 싶은 경우를 위한 데이터 저장소이다.

<br />

![엠큐](https://user-images.githubusercontent.com/33855307/140751170-e6d716cd-8c6a-4df3-b711-379b295c8740.png)


<br />

위 이미지가 AMQP을 나타낸 것이다.

예) `업무 내용을 분류해서 메신저로 보내주시면 처리 후에 결과 알려드리겠습니다.`

* Publisher: '다른 직원들'
* Exchange: '분류해서'
* binding: '보내주시면' 
* Queue: '메신저'
* Consumer: '처리 후에 알려드리겠습니다.'

<br />
<br />

## Message와 Queue 보존

메시징이 일시적으로 문제가 발생하게 되면 쿼리 디비를 반영해야 할 데이터가 유실될 수 있다고 한다.

RabbitMQ가 종료되면 Queue와 안에있는 message는 모두 제거된다. 

하지만 Queue를 선언할 때 durable 속성을 true로 설정하면 RabbitMQ가 종료된 후 다시 시작될 때 해당 Queue는 다시 자동으로 생성된다. 

하지만 이렇게 해도 Queue 내부의 메세지는 여전히 삭제된다.

이를 방지하려면 Publisher가 message를 Exchange로 보낼 때 persistent 속성을 부여하면 된다. 

그러면 메세지도 다시 생성될 것이다.

<br />
<br />


## Message Queue 특징 & 장점

#### 비동기(Asynchronous)

요청이 몰릴 때에도 저장했다가 처리할 수 있다. 

즉 DB 속도와 무관하게 모든 요청을 처리할 수 있다는 것이다. 

앞쪽 애플리케이션은 실제 로직이 수행되는 것과 무관하게 

단순히 큐에 넣고 다음 요청을 받을 수 있는 상태가 되는 것이다. 

<br />

#### 애플리케이션간 의존성 제거(비동조, Decoupling)  

API를 직접 호출하는 것과 중간에 큐가 있는 것 중 뒷쪽에 있는 애플리케이션이 중단되었을 때에도 메시지가 유실되지 않는다.   

<br />

#### 과잉(Redundancy)  

실패할 경우 재실행 가능하다. 

<br />

#### 보증(Guarantees)

Queue에 따로 적재된 작업들을 모니터링 할 수 있다.

<br />

#### 확장성(Scalable)

다양한 애플리케이션이 message를 생산할 수 있다.

<br />

#### 이중화  

큐도 결국 애플리케이션이다. 큐도 죽을 수 있는데 이중화도 가능하다. 

큐끼리 동기화하기 때문에 우리는 하나의 큐인 것처럼 사용하지만 실제 이중화된 큐를 사용할 수 있다.   

<br />

#### 신뢰성 

실패한 메시지는 큐로 Ack하지 않기 때문에 그 메시지는 큐에서 빠져나가지 않는다. 

하지만 절대로 유실되지 않는다고 보장할 수는 없다. 

유실되면 안되는 메시지는 로깅을 철저히하여 유실되더라도 복구할 수 있게 준비해야 한다. 

<br />

#### 확장성 

애플리케이션이 스케일 아웃 하더라도 메시지큐에서 따로 처리해줄 필요는 없다. 

사용하던 큐를 그대로 사용할 수 있다.



<br />
<br />

## RabbitMQ 사용법 

#### 설치 

```shell
docker run -d --hostname my-rabbit --name some-rabbit -p 5672:5672 -p 15672:15672 rabbitmq:3-management
```

<br />

#### Consumer 예제 코드 

```java
@Component
public class Consumer {

    @Autowired
    ObjectMapper objectMapper;

    @Autowired
    PostRepository postRepository;

    @RabbitListener(queues = "CREATE_POST_QUEUE")
    public void handler(String message) throws JsonProcessingException {
        Post post = objectMapper.readValue(message, Post.class);
        postRepository.save(post);
    }
}
```

<br />

#### Producer 예제 코드

```java
@Component
public class Producer {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void sendTo(String message) {
        this.rabbitTemplate.convertAndSend("CREATE_POST_QUEUE", message);
    }

}
```

<br />




