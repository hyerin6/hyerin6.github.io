---
layout: post
title: "Spring Security"  
description: "2020-04-17 litebook"
date: 2020-04-17
tags: [litebook]
comments: true
share: true
--- 

## 1. Spring Security의 구조           

<img width="967" alt="스크린샷 2020-04-18 오전 12 28 42" src="https://user-images.githubusercontent.com/33855307/79586183-bfc1e480-810b-11ea-8ad5-3ddee1094e4b.png">    

1.1 유저가 로그인을 시도한다.      
1.2 `AuthenticationFilter` 에서 `UserDetails`로 User DB에 접근한다.     
1.3 DB에 있는 user라면 `UserDetails`에서 꺼내 session을 생성한다.     
1.4 spring security의 인메모리 세션저장소인 `SecurityContextHolder`에 저장한다.      
1.5 user에게 session ID와 함께 응답한다.       
1.6 이후 사용자의 요청에서는 요청 쿠키에서 JSESSIONID를 검증해 유효하면 `Authentication`을 준다.       


## 2. Spring Security - 인증 절차 인터페이스     
### 1. UserDetails     
각기 다른 어플리케이션의 User에 해당하는 Model에 UserDetails를 implements하여   
spring security가 이애할 수 있는 형태의 User로 만들어줘야 한다.   

로그인 로직에서 사용자가 입력한 정보와 DB에 저장된 사용자의 정보를 비교해야 하는데   
UserDetails 인터페이스는 사용자의 정보를 담아두는 VO 역할을 한다고 할 수 있다.   

UserDetails 인터페이스를 구현하려면 오러바이드해야 하는 메소드들이 있다.   
사용자 정보에 관한 다른 정보를 추가해도 된다.   
(다른 멤버변수들은 getter, setter를 만들어서 사용하면 된다.)     

- Collection<? extends GrantedAuthority> getAuthorities()       
계정이 갖고있는 권한 목록을 리턴한다.      

- String getPassword()  
계정의 비밀번호를 리턴한다.   

- String getUsername()   
계정의 이름을 리턴한다.   

- boolean isAccountNonExpired()    
계정이 만료되지 않았는지 리턴한다. (true : 만료되지 않음)  

- boolean isAccountNonLocked()  
계정이 잠겨있지 않았는지 리턴한다. (true : 잠기지 않음)  

- boolean isCredentialNonExpired()      
비밀번호가 만료되지 않았는지 리턴한다. (true : 만료되지 않음)     

- boolean isEnabled()     
계정이 활성화(사용가능)인지 리턴한다. (true: 활성화)    


UserDetails 인터페이스는 User Entity 클래스에 구현하지 않고,   
CustomUserDetails 클래스에 implements한다.     

CustomUserDetails.java      
    
```java    
public class CustomUserDetails implements UserDetails {
    private Long id;
    private String email;
    private String password; 
    
    @Enumerated(EnumType.STRING)
    private Role userType;
     
    private boolean enabled;
    
    @ElementCollection(fetch = FetchType.EAGER)
    @Builder.Default
    private List<String> roles = new ArrayList<>();
    
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
    return this.roles.stream()
               .map(SimpleGrantedAuthority::new)
               .collect(Collectors.toList());
    }
    
    @Override
    public String getUsername() { return null; }
    
    @Override
    public boolean isAccountNonExpired() { return false; }
    
    @Override
    public boolean isAccountNonLocked() { return false; }
    
    @Override
    public boolean isCredentialsNonExpired() { return false; }

}   
```  

위 코드는 이번 프로젝트에서 사용한 UserDetails 인터페이스의 일부이다.    



### 2. UserDetailsService    
UserDetailsService 인터페이스에는     
DB에서 사용자 정보를 불러오는 메소드를 오버라이드 해야 한다.        
loadUserByUsername() 메소드이다.     
이 메소드에서 사용자 정보를 불러오는 작업을 하면 된다.     
CustomUserDetails 타입으로 사용자의 정보를 가져오면 된다.      

사용자 정보 유/무에 따라 예외, 사용자 정보를 리턴하면 된다.   


```java    
@RequiredArgsConstructor
@Service
public class CustomUserDetailsService implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        return (UserDetails) userRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("사용자를 찾을 수 없습니다."));
    }
} 
```      

위 코드는 이번 프로젝트에서 사용한 UserDetailsService 인터페이스의 일부이다.      



### 3. AuthenticationProvider       
AuthenticationProvider 인터페이스는        
사용자가 입력한 로그인 정보와 DB에서 가져온 사용자의 정보를 비교해주는 인터페이스이다.       
  
해당 인터페이스에 오버라이드되는 authenticate() 메소드는 
화면에 사용자가 입력한 로그인 정보를 담고있는 Authentication 객체를 갖고 있다.   















