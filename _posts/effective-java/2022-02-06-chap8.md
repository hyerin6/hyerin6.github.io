---   
layout: post  
title: "메서드 설계 시 주의할 점"    
description: "effective java chap8"  
date: 2022-02-06     
tags: [effective-java, java]  
categories: [Effective Java, Java]  
comments: true    
share: true
---

<br />


## 49. 매개변수가 유효한지 검사하자.  

매개변수의 불완전한 검사로 생기는 문제점은 다음과 같다.  

* 메서드가 수행되는 중간에 모호한 예외를 던진다. 
* 메서드가 잘 수행되지만 잘못된 결과를 반환한다.
* 메서드는 문제없이 수행되지만 이 메서드와 상관 없는 오류를 발생시킬 가능성이 높아진다.


**매개변수의 검사에 실패하면 실패원자성을 어기는 결과를 낳을 수 있다.**      
실패 원자성이란, 호출된 메서드가 실행에 실패하더라도 객체 상태는 메소드 호출 전과 같아야 함을 뜻함.      
<br />

#### 매개변수 유효 검사할 때      
* public, protected 메서드는 던지는 예외를 문서화하자.
* public이 아닌 메서드라면 단언문(assert)을 사용해 매개변수 유효성을 검증하자.
* 메서드가 직접 사용하지 않지만 나중을 위해 저장되는 매개변수는 더 신경써서 검사하자.
* 잘못된 매개변수 값을 사용해 발생한 예외는 예외 번역 관용구를 사용해 API 문서에 기재된 예외로 번역하자.

<br />
<br />

## 50. 적시에 방어적 복사본을 만들자.
자바는 네이티브 메서드를 사용하지 않으니 C, C++ 같이 안전하지 않은 언어에서 흔히 보는 버퍼 오버런, 배열 오버런, 와일드 포인터 같은 메모리 충돌 오류에서 안전하다.     
자바로 작성한 클래스는 시스템의 다른 부분에서 무슨 짓을 하더라도 그 불변식이 지켜진다.         
하지만 아무런 노력 없이 다 막을 수 있는 것은 아니다.    
클라이언트가 불변식을 깨뜨리려 한다고 가정하고 방어적으로 프로그래밍해야 한다.   
<br />    


#### 기간을 표현하는 클래스: 불변식을 지키지 못한 경우 

```java
public final class Period {
    private final Date start;
    private final Date end;

    /**
     * @param  start 시작 시각
     * @param  end 종료 시각. 시작 시각보다 뒤여야 한다.
     * @throws IllegalArgumentException 시작 시각이 종료 시각보다 늦을 때 발생한다.
     * @throws NullPointerException start나 end가 null이면 발생한다.
     */
    public Period(Date start, Date end) {
        if (start.compareTo(end) > 0)
            throw new IllegalArgumentException(
                    start + "가 " + end + "보다 늦다.");
        this.start = start;
        this.end   = end;
    }

    public Date start() {
        return start;
    }
    public Date end() {
        return end;
    }

    public String toString() {
        return start + " - " + end;
    }
    
    . . .
    
```

이 클래스가 불변처럼 보이지만, Date가 가변이라는 사실을 이용하면 불변식을 깨뜨릴 수 있다.     

```java
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
end.setYear(78); // p의 내부를 수정했다. 
```

자바 8 이후로 다행히 Date 대신 불변인 Instant를 사용하면 된다.   
(혹은 LocalDateTime, ZonedDateTime 사용 가능)   
Date는 낡은 API 이므로 새로운 코드를 작성할 때 더 이상 사용하면 안 된다.    


외부 공격으로부터 Period 인스턴스의 내부를 보호하려면      
생성자에서 받은 가변 매개변수 각각을 방어적으로 복사(defensive copy)해야 한다.   
Period 인스턴스 안에서는 원본이 아닌 복사본을 사용한다.   
<br />    

#### 매개변수의 방어적 복사본을 만드는 경우 

```java
public Period(Date start, Date end) {
    this.start = new Date(start.getTime());
    this.end   = new Date(end.getTime());

    if (this.start.compareTo(this.end) > 0)
        throw new IllegalArgumentException(
            this.start + "가 " + this.end + "보다 늦다.");
    }
}
```

매개변수의 유효성을 검사하기 전에 방어적 복사본을 만들고, 이 **복사본으로 유효성 검사**를 했다.   
순서가 부자연스러워보여도 반드시 이렇게 작성해야 한다.   
멀티스레딩 환경에서 원본 객체의 유효성을 검사한 후 복사본을 만들면 찰나의 취약한 순간에 다른 스레드가 원본 객체를 수정할 위험이 있기 때문이다.   

방어적 복사에 Date의 clone 메서드를 사용하지 않는데,   
Date는 final이 아니기 때문에 clone이 Date가 정의한 게 아닐 수 있다.    
즉, clone이 악의를 가진 하위 클래스의 인스턴스를 반환할 수도 있다.   
이런 공격을 막기 위해 **매개변수가 제3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용해서는 안 된다.**  

복사본까지 만들었지만 아직 접근자 메서드가 있다.   

```java
public Date start() {
    return new Date(start.getTime());
}
```

두 번째 공격을 막아내려면 단순히 접근자가 가변 필드의 방어적 복사본을 반환하면 된다.   


> 생성자와 달리 접근자 메서드(getter)에서는 방어적 복사에 clone을 사용해도 된다.    
> Period가 가지고 있는 Date 객체가 java.util.Date임이 확실하기 때문이다.  
>  하지만 인스턴스 복사에는 일반적으로 생성자나 정적 팩터리를 쓰는게 좋다.  

모든 필드가 객체 안에 완벽하게 캡슐화되었다.   

<br /> 

#### ● 클래스의 가변, 불변 여부와 상관없이 가변인 내부객체를 클라이언트에 반환할 때는 반드시 심사숙고 하자.   
#### ● 되도록 불변 객체들을 조합해 객체를 구성해야 방어적 복사를 할 일이 줄어든다.  
#### ● 방어적 복사를 생략해도 되는 상황은 해당 클래스와 그 클라이언트가 상호 신뢰할 수 있을 때, 혹은 불변식이 깨지더라도 그 영향이 오직 호출한 클라이언트로 국한될 때로 한정해야 한다.   


<br />
<br />


