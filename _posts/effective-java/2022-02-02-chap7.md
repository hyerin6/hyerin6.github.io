---   
layout: post  
title: "람다와 스트림"    
description: "effective java chap7"  
date: 2022-02-02     
tags: [effective-java, java]
categories: [Effective Java, Java]
comments: true    
share: true
---  

자바 8에서 함수형 인터페이스, 람다, 메서드 참조라는 개념이 추가되어 함수 객체를 더 쉽게 만들 수 있게 되었다.   

---


## 42. 익명 클래스보다는 람다를 사용하자.
자바에서 함수 타입을 표현       
`추상 메서드를 하나만 담은 인터페이스` → `익명 클래스` → `람다식`        


* 익명 클래스의 인스턴스를 함수 객체로 사용   

```java 
Collections.sort(words, new Comparator<String>() {
    public int compare(String s1, String s2) {
        return Integer.compare(s1.length(), s2.length());
    }
});
```

익명 클래스는 코드가 너무 길어 자바는 함수형 프로그래밍에 적합하지 않았다.   
자바8에서 람다식을 사용하게 되면서 특별 대우를 받게 되었다.    


* 람다식을 함수 객체로 사용

```java 
Collections.sort(words,
    (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```

매개변수, 반환값 타입을 컴파일러가 문맥을 살펴 추론해준다.  


<br />

람다식이 많이 쓰이면서 익명 클래스가 잘 쓰이지 않았지만, 람다로 대체할 수 없는 곳이 있다.  

* 추상 클래스의 인스턴스를 만들 때 람다를 쓸 수 없으니 익명 클래스를 써야 한다. 


* 람다는 자신을 참조할 수 없다. 람다에서 `this` 키워드는 바깥 인스턴스를 가리킨다. 
  따라서 함수 객체가 자신을 참조해야 한다면 반드시 익명 클래스를 써야 한다. 


* 람다도 익명 클래스처럼 직렬화 형태가 구현별로 다를 수 있다.   
  따라서 람다를 직렬화하는 일은 삼가해야 한다.     
  직렬화해야 한다면 private 정적 중첩 클래스의 인스턴스를 사용해야 한다.   

<br />  
<br />  

## 43. 람다보다는 메서드 참조를 사용하자. 
람다가 익명 클래스보다 나은 점 중 가장 큰 특징은 간결함이다.    
람다보다 더 간결하게 만드는 방법이 있는데, **메서드 참조**이다.  

```java
map.merge(key, 1, (count, incr) -> count + incr);
```

깔끔해 보이지만 위 코드에 count, incr 매개변수는 크게 하는 일 없이 공간을 꽤 차지한다.    
 
자바 8이 되면서 Integer 클래스(와 모든 기본 타입의 박싱 타입)는   
이 람다와 기능이 같은 정적 메서드 sum을 제공하기 시작했다.     

람다 대신 이 메서드의 참조를 전달하면 똑같은 결과를 더 간결하게 표현할 수 있다.  

```java
map.merge(key, 1, Integer::sum);
```

람다로 할 수 없는 일은 메서드 참조로도 할 수 없다. (예외가 있긴함)  

<br />

#### 5가지 메서드 참조  

| 메서드 참조 유형 | 예 | 같은 기능을 하는 람다 |
|:---|:---|:---|
|정적| `Integer::parseInt` | `str -> Integer.parseInt(str)` |
|한정적(인스턴스)| `Instant.now()::isAfter` | `Instant then = Instant.now();` <br /> `t -> then.isAfter(t)` |
|비한정적(인스턴스)| `String::toLowerCase` | `str -> str.toLowerCase()` |
|클래스 생성자| `TreeMap<K, V>::new` | `() -> new TreeMap<K, V>()` |
|배열 생성자| `int[]::new` | `len -> new int[len]` |


<br />  
<br />  

## 44. 표준 함수형 인터페이스를 사용하자.
자바가 람다를 지원하면서 상위 클래스의 기본 메서드를 재정의해 원하는 동작을 구현하는 템플릿 메서드 패턴의 매력이 크게 줄었다.   
이를 대체하는 해법은 같은 효과의 함수 객체를 받는 정적 팩토리나 생성자를 제공하는 것이다.   
즉 함수 객체를 매개변수로 받는 생성자와 메서드를 더 많이 만들어야 한다.   
이때 함수형 매개변수 타입을 올바르게 선택해야 한다.   

<br />  

#### 예) LinkedHashMap `removeEldesEntry()`: return 값이 true이면 가장 오래된 원소를 제거한다.  

* 메서드 재정의 

```java
protected boolean removeEldesEntry(Map.Entry<K, V> eldet) {
    return size() > 100;
}
```

위 코드도 잘 동작하지만, LinkedHashMap을 다시 구현한다면 함수 객체를 받는 정적 팩토리나 생성자를 제공했을 것이다.    
removeEldestEntry는 `size()`를 호출해 맵 안의 원소 수를 알아내는데   
removeEldestEntry가 인스턴스 메서드라서 가능한 방식이다.   

하지만 생성자에 넘기는 함수 객체는 이 맵의 인스턴스 메서드가 아니다.    
팩토리나 생성자를 호출할 때는 맵의 인스턴스가 존재하지 않기 때문이다.   
따라서 맵은 자기 자신도 함수 객체에 건네줘야 한다.   
이를 반영한 함수형 인터페이스는 다음과 같이 선언할 수 있다.      
<br />  

* 함수형 인터페이스 

```java
@FunctionalInterface interface EldesEntryRemovalFunction<K, V> {
    boolean remove(Map<K, V> map, Map.Entry<K, V> eldest);
}
```

이 인터페이스도 잘 동작하지만, 굳이 사용할 이유는 없다.   
자바 표준 라이브러리에 이미 같은 인터페이스가 있다.   
`java.util.function` 패키지를 보면 다양한 표 준 함수형 인터페이스가 있다.  
필요한 용도에 맞는게 있다면, 직접 구현하지 않고 표준 함수형 인터페이스를 활용하면 된다.   

이 예제의 LinkedHashMap에서 직접 만든 메서드가 아닌    
표준 인터페이스인 `BiPredicate<Map<K, V>, Map.Entry<K, V>>`를 사용할 수 있다.          

<br />   

#### 표준 함수형 인터페이스 / 직접 구현한 함수형 인터페이스 
* 표준 함수형 인터페이스 대부분은 기본 타입만 지원한다. 
  그렇다고 기본함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지 말자. 성능이 느려질 수 있다. 


* 다음 하나 이상을 만족해야 한다면 전용 함수형 인터페이스 구현을 고민해야 한다. 
    - 자주 쓰이며, 이름 자체가 용도를 명확히 설명해준다.
    - 반드시 따라야 하는 규약이 있다.
    - 유용한 디폴트 메서드를 제공할 수 있다. 


* 직접 만든 함수형 인터페이스에는 항상 `@FunctionalInterface` 어노테이션을 사용하자. 


* 서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드들을 다중 정의하면 안된다. 


















