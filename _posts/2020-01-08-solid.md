---
layout: post
title: "객체 지향 설계 5원칙 - SOLID"
description: "응집도는 높이고, 결합도는 낮춰라 ~"
date: 2020-01-08
tags: [java, oop]
comments: true
share: true
---
   
- SRP(Single Responsibility Principle) 단일 책임 원칙   
- OCP(Open Closed Principle) 개방 폐쇄 원칙   
- LSP(Liskov Substitution Principle) 리스코프 치환 원칙   
- ISP(Interface Segregation Principle) 인터페이스 분리 원칙    
- DIP(Dependency Inversion Principle) 의존 역전 원칙   

# 높은 응집도와 낮은 결합도   
개방 폐쇄 원칙은 높은 응집도와 낮은 결합도라는 소프트웨어 개발의 원리로 설명이 가능하다.   
응집도가 높다는 것은 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다.    
불필요하거나 직접 관련이 없는 외부의 관심과 책임이 얽혀 있지 않으며, 하나의 공통 관심사는 한 클래스에 모여 있다.   
높은 응집도는 클래스 레벨뿐 아니라 패키지, 컴포넌트, 모듈에 이르기까지 그 대상의 크기가 달라도 동일한 원리로 적용될 수 있다.   

- 높은 응집도   
응집도가 높다는 것은 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻   
혹은, 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것으로도 설명할 수 있다.     
불필요하거나 직접 관련이 없는 외부의 관심과 책임이 얽혀 있지 않으며, 하나의 공통 관심사는 한 클래스에 모여 있다.   
즉 변경이 일어날 때 모듈의 많은 부분이 함께 바뀐다면 응집도가 높다는 것이다.   
만약 모듈의 일부분에만 변경이 일어나도 된다면, 모듈 전체에서 어떤 부분이 바뀌어야 하는지 파악해야 하고, 
또 그 변경으로 인해 바뀌지 않는 부분에는 다른 영향을 미치지는 않는지 확인해야 하는 이중의 부담이 생기다.   

- 낮은 결합도   
책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는 것이 바람직하다.    
느슨한 연결은 관계를 유지하는 데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고, 나머지는 서로 독집적이고 알 필요도 없게 만들어주는 것이다.      
결합도가 낮아지면 변화에 대응하는 속도가 높아지고, 구성이 깔끔해진다. 또한 확장하기에도 매우 편리하다.   
여기서 결합도란 '하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도'라고 설명할 수 있다.   
낮은 결합도란 결국, 하나의 변경이 발생할 때 여타 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태를 말한다.   

- 결합도와 응집도   
좋은 소프트웨어 설계를 위해서는 결합도는 낮추고 응집도는 높이는 것이 바람직하다.   
결합도는 모듈(클래스) 간의 상호 의존 정도로서 결합도가 낮으면 모듈 간의 상호 의존성이 줄어들어 객체의 재사용이나 수정, 유지보수가 용이하다.   
응집도는 하나의 모듈 내부에서 존재하는 구성 요소들의 기능적 관련성으로, 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져   
재사용이나 기능의 수정, 유지보수가 용이하다.   


### 1. SRP - 단일 책임 원칙        
"어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다."       
  
역할(책임)을 분리하라는 것이 단일 책임 원칙이다.   
단일 책임 원칙은 속성, 메서드, 패키지, 모듈, 컴포넌트, 프레임워크 등에도 적용할 수 있다.   
단일 책임 원칙과 객체 지향 4대 특성은 어떻게 결부돼 있을까?  
단일 책임 원칙과 가장 관계가 깊은 것은 바로 모델링 과정을 담당하는 추상화임을 알 수 있다.   
애플리케이션의 경계를 정하고 추상화를 통해 클래스들을 선별하고 속성과 메서드를 설계할 때 반드시 단일 책임 원칙을 고려하는 습관을 들이자.     


### 2. OCP - 개방 폐쇄 원칙     
"소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다."  
→ 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.   

개방 폐쇄 원칙을 무시하고 프로그램을 작성하면 객체 지향 프로그래밍의 가장 큰 장점인 유연성, 재사용성, 유지보수성 등을 얻을 수 없다.     


### 3. LSP - 리스코프 치환 원칙    
"서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다." 
  
객체 지향에서의 상속은 조직도나 계층도가 아닌 뷴류도가 되어야 한다.   
객체 지향의 상속은 다음의 조건을 만족해야 한다.   
- 하위 클래스 is a kind of 상위 클래스 → 하위 분류는 상위 분류의 한 종류이다.   
- 구현 클래스 is able to 인터페이스 → 구현 분류는 인터페이스할 수 있어야 한다.   

"하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다."  

리스코프 치환 원칙    
- 하위형에서 선행 조건은 강화될 수 없다.   
- 하위형에서 후행 조건은 약화될 수 없다.   
- 하위형에서 상위형의 불변 조건은 반드시 유지돼야 한다.   


### 4. ISP - 인터페이스 분리 원칙   
"클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다."    

단일 책임 원칙에서 제시한 해결책은 클래스를 토막내서 하나의 역할(책임)만 하는 다수의 클래스로 분할하는 것이었다.   
그런데 꼭 그 방법뿐일까? 다른 선택 방법은 바로 ISP 즉, 인터페이스 분할 원칙이다.   
결론적으로 단일 책임 원칙(SRP)과 인터페이스 분할 원칙(ISP)은 같은 문제에 대한 두 가지 다른 해결책이라고 볼 수 있다.   
특별한 경우가 아니라면 단일 책임 원칙을 사용하는 것이 더 좋다.   

인터페이스 분할 원칙을 이야기할 때 등장하는 원칙 중 하나로 인터페이스 최소주의 원칙이라는 것이 있다.   
인터페이스를 통해 메서드를 외부에 제공할 떄는 최소한의 메서드만 제공하라는 것이다.   
상위 클래스는 풍성할수록 좋고, 인터페이스는 작을수록 좋다고 했다. 그 이유는 리스코프 치환 원칙(LSP)에 따라 하위 객체는 상위 객체인 척 할 수 있다.   


### 5. DIP - 의존 역전 원칙   
"추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다."  
자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에   
영향을 받지 않게 하는 것이 의존 역전 원칙이다.   


### 6. 정리   
- SRP(단일 책임 원칙) : 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.   
- OCP(개방 폐쇄 원칙) : 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.    
- LSP(리스코프 치환 원칙) : 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.    
- ISP(인터페이스 분리 원칙) : 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.       
- DIP(역전 의존 원칙) : 자신보다 변하기 쉬운 것에 의존하지 마라.    


